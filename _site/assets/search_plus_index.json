{"/pages/2022-03-01-Overview/": {
    "title": "Overview",
    "keywords": "Jekyll",
    "url": "/pages/2022-03-01-Overview/",
    "body": "How to use these pages RBG-Maxwell is currently under inner test. The code will be given under request Jun-Jie Zhang (zjacob@mail.ustc.edu.cn) or Ming-Yan Sun (sunmingyan0301@163.com) If you use our program, we have provided two places to cite in Acknowledging. Details of the various functions in the program are provided in General Structure. Finally, you can find out how to use each module in Example, which will help you to get a better understanding of RGB-Maxwell. Installation Acknowledging General Structure How to use RBG-Maxwell Input parameters Plasma Collision_database Collision Vlasov_Drifit_terms EMsolver Unit_Conversion Straitified_time_updation Macro_quantities Externel-forces Example Test Conversion Test_pure_electron_plasma Test_circle_pure_electron_plasma Test large_scale_plasma term Test_collision_term"
  },"/pages/2022-04-01-Installation/": {
    "title": "Installation",
    "keywords": "",
    "url": "/pages/2022-04-01-Installation/",
    "body": "RBG-Maxwell is written in python, so the user needs to ensure that the following packages are installed before running the program import numba ----numba is a JIT compiler that can compile python functions into machine code； import math; ----math provides a number of mathematical functions for floating point numbers； import cupy; ----cupy is an implementation of NumPy-compatible multidimensional arrays on CUDA; import ray; ----Ray is a distributed execution framework; import random; ----random is a standard library that generates random numbers； import numpy; ----NumPy is the base package for scientific computing in Python； import os; ----os is a module in the Python standard library for accessing operating system functions； import sys; ----sys is a module to handle the python runtime environment。 To use RBG-Maxwell with JupyterLab, make sure the following file structures. The structure of the RBG-Maxwell framework can be found at General Structure"
  },"/pages/2022-05-01-Acknowledging-RBG-Maxwell/": {
    "title": "Acknowledging RBG-Maxwell",
    "keywords": "",
    "url": "/pages/2022-05-01-Acknowledging-RBG-Maxwell/",
    "body": "The package is coded byJun-Jie Zhang and improved by Ming-Yan Sun. The project will be consistently maintained by Ming-Yan Sun and Jun-Jie Zhang . For further help, please contact us at zjacob@mail.ustc.edu.cn Jun-Jie Zhang and sunmingyan0301@163.com Ming-Yan Sun This package is free you can redistribute it and/or modify it under the terms of the Apache License Version 2.0, January 2004. [Licenses][http://www.apache.org/licenses/] To cite our work, please use the following three items: @article{XXXXXX, title = {Utilization of the RBG-Maxwell framework for collisionless plasma at atmospheric scales}, author = {Ming-Yan Sun,Peng Xu, Tai-Jiao Du, Jin-Ming Hu, Jin-Jun Li, Jun-Jie Zhang}, journal = {IEEE T COMPUT}, volume = {}, issue = {}, pages = {}, numpages = {}, year = {}, month = {}, publisher = {}, doi = {}, url = {} } @article{PhysRevD.102.074011, title = {Towards a full solution of the relativistic Boltzmann equation for quark-gluon matter on GPUs}, author = {Zhang, Jun-Jie and Wu, Hong-Zhong and Pu, Shi and Qin, Guang-You and Wang, Qun}, journal = {Phys. Rev. D}, volume = {102}, issue = {7}, pages = {074011}, numpages = {17}, year = {2020}, month = {Oct}, publisher = {American Physical Society}, doi = {10.1103/PhysRevD.102.074011}, url = {https://link.aps.org/doi/10.1103/PhysRevD.102.074011} } @article{ZHANG2022108328, title = {JefiGPU: Jefimenko equations on GPU}, author = {Jun-Jie Zhang and Jian-Nan Chen and Guo-Liang Peng and Tai-Jiao Du and Hai-Yan Xie}, journal = {Computer Physics Communications}, volume = {276}, pages = {108328}, year = {2022}, issn = {0010-4655}, doi = {https://doi.org/10.1016/j.cpc.2022.108328}, url = {https://www.sciencedirect.com/science/article/pii/S0010465522000467}, }"
  },"/pages/2022-06-01-General-Structure/": {
    "title": "General Structure",
    "keywords": "",
    "url": "/pages/2022-06-01-General-Structure/",
    "body": "The main structure of RBG-Maxwell is shown in the figure. Providing the proper initial distributions, masses, charges,differential cross sections and external forces (not limited to electromagnetic forces), the RBG-Maxwell framework can perform the evolution of a particle system from non-equilibration to thermal state. RBG-Maxwell is particularly suitable for calculating collisional plasmas with open physical boundaries, or the evolution of collision-free plasmas on large scales. The main calculation process of RBG-Maxwell framework: First, RBG-Maxwell receives the single particle distribution function. The program splits the distribution function and transfers it to different GPU blocks.； EM Solver uses single-particle functions and phase space to calculate charge density functions and current density functions； EM solver uses current density and charge density to calculate electric and magnetic fields； EM solver calculates external electromagnetic forces with electromagnetic fields； BM solver calculates collision terms using single particle distribution functions; BM solver calculation the drift term using single particle distribution function and external electromagnetic force； RBG-Maxwell combines the collision term, single-particle distribution function, and external electromagnetic force to calculate the single-particle distribution function for the next moment; The program completes the evolutionary process of the physical system by continuously iterating the above process."
  },"/pages/2022-07-01-How%20to%20use%20RBG-Maxwell/": {
    "title": "How to use RBG-Maxwell",
    "keywords": "",
    "url": "/pages/2022-07-01-How%20to%20use%20RBG-Maxwell/",
    "body": "The main purpose of this part is to let users quickly master the use of RBG-Maxwell framework. RBG-Maxwell 1、Usage via an example ​ The following codes demonstrate an example of how to use RBG-Maxwell. 1.1、 Set the initial conditions 1、First, we need to invoke the following package： import warnings warnings.filterwarnings(\"ignore\") # specify the system from RBG_Maxwell.Collision_database.select_system import which_system plasma_system = 'Fusion_system' which_system(plasma_system) from RBG_Maxwell.Collision_database.Fusion_system.collision_type import collision_type_for_all_species from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion import numpy as np from RBG_Maxwell.Plasma.main import Plasma 2、Then, we need to specify the unit conversion factor： Determine the conversion factors for the International System of Units (IS) and the Flexible System of Units (FS) by configuring the spatial grid, velocity, and charge parameters. # here we use a pure electron system # give the quantities in SI # the spatial grid is chosen to be dx=dy=10**(-5) m dx = dy = 10**(-5) dz = 1. # velocity is roughly 5*10**(6) m/s v = 5*10**6 # charge Q = 1.6*10**(-19) # momentum is roughly 10**(-30)kg*10**7m/s momentum = 10**(-23) dp = (10**(-25)*10**(-23)*10**(-23))**(1/3) # the total number of particles are 5*10**(-13)/(1.6*10**(-19)) # put these particles in 71 spatial grids in z direction # in 201 spatial grids in y direction # and 100 momentum grids # in each phase grid we have dn = 21.89755448111554 # the average value of distribution is roughly dn = 0.2189755448111554 f = dn/(dp**3*dx*dy*dz) df = f # time scale dt = 10**(-13) # Now find the coefficient hbar, c, lambdax, epsilon0 = determine_coefficient_for_unit_conversion(df, dx, dp, Q, f, v, dt) conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) conversion_table_reverse = \\ unit_conversion('LHQCD_to_SI', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) For a detailed procedure of unit conversion you can refer to Conversion. 3、Next, we need to initialize the plasma system： The primary dataset comprises the parameters for time-space discretization, grid quantities, particle classification, and collision classification. In the present demonstration, a two-dimensional system consisting of pure electron plasma is utilized, and the initial spatial arrangement of the system is depicted in below. # time step, and spatial infinitesimals # dt is 10**(-13) s, dx = dy = dz = 10**(-5) m dt, dx, dy, dz = 10**(-13)*conversion_table['second'], \\ 10**(-5)*conversion_table['meter'], \\ 10**(-5)*conversion_table['meter'], \\ 10**(-5)*conversion_table['meter'] dt_upper_limit = float(10**(-1)*conversion_table['second']) dt_lower_limit = float(10**(-9)*conversion_table['second']) # we have only one type of particle e- num_particle_species = 1 # treat the electron as classical particles particle_type = np.array([0]) # masses, charges and degenericies are masses, charges, degeneracy = np.array([9.11*10**(-31)*conversion_table['kilogram']]), \\ np.array([-1.6*10**(-19)*conversion_table['Coulomb']]),\\ np.array([1.]) # momentum grids npx, npy, npz = 1, 201, 1 # half_px, half_py, half_pz # momentum range for x and z direction are not import in this case half_px, half_py, half_pz = np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]), \\ np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]),\\ np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]) par_list=[m1**2*c**2, m2**2*c**2, (2*math.pi*hbar)**3, hbar**2*c, d_sigma/(hbar**2)] dpx, dpy, dpz = 2*half_px/npx, 2*half_py/npy, 2*half_pz/npz # load the collision matrix flavor, collision_type, particle_order = collision_type_for_all_species() expected_collision_type = ['2TO2'] The parameters related to collisions can be found in Collision_database. The program describes in detail how to set up different colliding plasmas. We also set up the quark-gluon plasma system and the fusion system in this program. 4、Set parallel calculation parameters for the plasma system： Including the number of Monte Carlo particles, the number of regions, the number of GPUs in the regions, etc. # number of spatial grids # must be integers and lists # odd numbers are recomended # the maximum spatial gird is limited by CUDA, it's about nx*ny*nz~30000 for each card nx_o, ny_o, nz_o = [1], [251], [111] # value of the left boundary # this is the x_left_bound_o, y_left_bound_o, z_left_bound_o = [-0.5*dx],\\ [-125.5*dy],\\ [-55.5*dz] # number samples gives the number of sample points in MC integration num_samples = 100 # Only specify one spatial region number_regions = 1 # each spatial should use the full GPU, this number can be fractional if many regions are chosen # and only one GPU is available num_gpus_for_each_region = 0.1 # since only one region is specified, this will be empty sub_region_relations = {'indicator': [[]],\\ 'position': [[]]} # if np.ones are used, the boundaries are absorbing boundaries # if np.zeros are used, it is reflection boundary # numbers in between is also allowed boundary_configuration = {} for i_reg in range(number_regions): bound_x = np.ones([ny_o[i_reg], nz_o[i_reg]]) bound_y = np.ones([nz_o[i_reg], nx_o[i_reg]]) bound_z = np.ones([nx_o[i_reg], ny_o[i_reg]]) boundary_configuration[i_reg] = (bound_x, bound_y, bound_z) For details, please refer to Plasma. 5、Set the distribution function and boundary conditions of the plasma system # iniital distribution function f = {} for i_reg in range(number_regions): f[i_reg] = np.zeros([num_momentum_levels, num_particle_species,\\ nx_o[i_reg], ny_o[i_reg], nz_o[i_reg], npx, npy, npz]) # The initial velocity of the electrons is 1.87683*10**6 m/s, corresponds to the momentum value # 9.11*10**(-31)*1.87683*10**6*conversion_table['momentum'] ~ 408.770512. # The following code specifies the momentum grid index dpy = 2*half_py/npy a = 9.11*10**(-31)*1.87683*10**6*conversion_table['momentum'] ipy = [i for i in range(npy) if (-half_py+dpy*(i-0.5))&lt;=a&lt;=(-half_py+dpy*(i+1))][0] ''' The total number of particles is 5*10**(-13)/(1.6*10**(-19)) ~ 31249999.999999996. Put these particles in 101 grids, the number density of the particles is 31249999.999999996/(101*dx*dy*dz) ~ 756837.0957070973 -&gt; Delta_N/Delta_V. The particles only possess the momentum region of size dpx*dpy*dpz, hence the distribution function at each phase space grid is 756837.0957070973/(dpx*dpy*dpz) ~ 756837.0957070973/(2*half_px/npx*2*half_py/npy*2*half_pz/npz) ~ 1234.63197049 ''' dn_dv = 5*10**(-14)/(1.6*10**(-19))/(101*dx*dy*dz*dpx*dpy*dpz) f[0][0, 0, 0,9,5:106,0,ipy,0] = dn_dv # reshape the distribution function in different regions for i_reg in range(number_regions): f[i_reg] = f[i_reg].reshape([num_momentum_levels, num_particle_species,\\ nx_o[i_reg]*ny_o[i_reg]*nz_o[i_reg]*npx*npy*npz]) ''' We add an external magnetic field of 10 T in the +y direction ''' BBy = [10*conversion_table['Tesla']*np.ones(nx_o[0]*ny_o[0]*nz_o[0])] BEx, BEy, BEz, BBx, BBz = [0],[0],[0],[0],[0] plasma = Plasma(f,par_list, dt, dt_lower_limit, dt_upper_limit,\\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ int(npx[0]), int(npy[0]), int(npz[0]), half_px, half_py, half_pz,\\ masses, charges, sub_region_relations,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type,\\ num_gpus_for_each_region,\\ hbar, c, lambdax, epsilon0, time_stride_back,\\ num_samples = 100, drift_order = 2,\\ rho_J_method=\"raw\", GPU_ids_for_each_region = [\"1\"]) 1.2、System evolution and results output Set the time step and perform the plasma system evolution. n_step = 10001 number_rho = [] EM = [] charged_rho = [] dis = [] VT= [] DT = [] import time start_time = time.time() for i_time in range(n_step): # if i_time%1000 == 0: # dis.append(plasma.acquire_values(\"Distribution\")) plasma.proceed_one_step(i_time, n_step, processes = {'VT':1., 'DT':1., 'CT':0.},\\ BEx = BEx, BEy = BEy, BEz = BEz, BBx = BBx, BBy = BBy, BBz = BBz) if i_time%1000 == 0: print('Updating the {}-th time step'.format(i_time)) number_rho.append(plasma.acquire_values(\"number_rho/J\")) charged_rho.append(plasma.acquire_values(\"Electric rho/J\")) EM.append(plasma.acquire_values('EM fields on current region')) end_time = time.time() Using pictures to show the evolution of the system. # spatial distribution import matplotlib.pyplot as plt xi, yi = np.mgrid[1:252:1,1:112:1] fig, axes = plt.subplots(ncols=5, nrows=2, figsize = (15,5)) for jj in range(2): for kk in range(5): axes[jj,kk].pcolormesh(xi, yi, number_rho[(jj*5+kk+1)][0][0].reshape([nx_o[0],ny_o[0],nz_o[0]])[0]) Users can easily build own plasma system by learning this example. For more details in the framework, please refer to Plasma For more examples, please refer to Example"
  },"/2022-08-10-test-collision.html": {
    "title": "Test collision",
    "keywords": "",
    "url": "/2022-08-10-test-collision.html",
    "body": "This procedure primarily discusses the computation of the collision term within the RBG-Maxwell framework. For detailed information regarding the specific structure and content of the program, please refer to Collision term Firstly, import the required packages for the program: import warnings warnings.filterwarnings(\"ignore\") import math # specify the system from RBG_Maxwell.Collision_database.select_system import which_system plasma_system = 'QGP_system' which_system(plasma_system) from RBG_Maxwell.Collision_database.QGP_system.collision_type import collision_type_for_all_species from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion import numpy as np # import the main class Plasma from RBG_Maxwell.Plasma.main import Plasma hbar, c, lambdax, epsilon0 = 1., 1., 1.6*10**28, 1. Next, input the model parameters. ##### We work in a 6-dimensional space with grid sizes # the region corresponds to the centrality of 20%~30%, impact parameter b = 8fm x_left_bound, y_left_bound, z_left_bound = -6./0.197,-6/0.197,-6/0.197 # GeV^-1 px_left_bound, py_left_bound, pz_left_bound = -2,-2,-2 # GeV x_grid_size, y_grid_size, z_grid_size = 1, 1, 1 # better be odd numbers px_grid_size, py_grid_size, pz_grid_size = 35,35,35 # better be odd numbers # The infinitesimal difference of x and p in the current example # dx, dy, dz are in unit of fm, dpx, dpy, dpz are in GeV dx, dy, dz = 2*abs(x_left_bound)/x_grid_size,2*abs(y_left_bound)/y_grid_size,2*abs(z_left_bound)/z_grid_size dpx, dpy, dpz = 2*abs(px_left_bound)/px_grid_size,2*abs(py_left_bound)/py_grid_size,2*abs(pz_left_bound)/pz_grid_size # dt is set the same for both BEsolver and EMsolver dt = 0.00025/0.197 # GeV^-1 dt_upper_limit = float(0.00025/0.197/1000) dt_lower_limit = float(0.00025/0.197*1000) # The regions for EM calculations are seperated as the source region and the observation region # In the current example, these regions aree the same as the BEsolver x_left_boundary_o, y_left_boundary_o, z_left_boundary_o = x_left_bound, y_left_bound, z_left_bound x_left_boundary_s, y_left_boundary_s, z_left_boundary_s = x_left_bound, y_left_bound, z_left_bound x_grid_size_o, y_grid_size_o, z_grid_size_o = x_grid_size, y_grid_size, z_grid_size x_grid_size_s, y_grid_size_s, z_grid_size_s = x_grid_size, y_grid_size, z_grid_size dx_o, dy_o, dz_o = dx, dy, dz dx_s, dy_s, dz_s = dx, dy, dz # particle types, 0: classical, 1: fermi, 2: boson # we have two types of particles particle_type = [0,0] # masses masses = np.array([0.3,0.3],dtype=np.float64) # GeV # charges correspond to u,d,s,u_bar,d_bar,s_bar and gluon unit_charge = math.sqrt(4*math.pi/137) # ratinalized Lorentz-Heaviside-QCD charges = np.array([unit_charge*2/3,-unit_charge/3],dtype=np.float64) degeneracy = np.array([1,1]) # number of total time steps n_step = 10001 # momentum grids npx, npy, npz = px_grid_size, py_grid_size, pz_grid_size # half_px, half_py, half_pz # momentum range for x and z direction are not import in this case half_px, half_py, half_pz = np.array([-px_left_bound]*2), \\ np.array([-py_left_bound]*2), np.array([-pz_left_bound]*2) par_list=[m1**2*c**2, m2**2*c**2, (2*math.pi*hbar)**3, hbar**2*c, d_sigma/(hbar**2)] # load the collision matrix flavor, collision_type, particle_order = collision_type_for_all_species() expected_collision_type = ['2TO2'] Then, you can configure the parallelization of the program and specify the number of GPUs to be used. # number of spatial grids # must be integers and lists # odd numbers are recomended # the maximum spatial gird is limited by CUDA, it's about nx*ny*nz~30000 for each card nx_o, ny_o, nz_o = [1], [1], [1] # value of the left boundary # this is the x_left_bound_o, y_left_bound_o, z_left_bound_o = [-6./0.197],[-6/0.197],[-6/0.197] # number samples gives the number of sample points in MC integration num_samples = 100 # Only specify one spatial region number_regions = 1 # each spatial should use the full GPU, this number can be fractional if many regions are chosen # and only one GPU is available num_gpus_for_each_region = 1. # since only one region is specified, this will be empty sub_region_relations = {'indicator': [[]],\\ 'position': [[]]} # if np.ones are used, the boundaries are absorbing boundaries # if np.zeros are used, it is reflection boundary # numbers in between is also allowed boundary_configuration = {} for i_reg in range(number_regions): bound_x = np.ones([ny_o[i_reg], nz_o[i_reg]]) bound_y = np.ones([nz_o[i_reg], nx_o[i_reg]]) bound_z = np.ones([nx_o[i_reg], ny_o[i_reg]]) boundary_configuration[i_reg] = (bound_x, bound_y, bound_z) Define the initial distribution of particles, primarily specifying the distribution in position space and momentum space. The function gives a step distribution function with the formula f(0,p) = f0*\\theta(1-p/Qs), usually Qs ~ 1 GeV, for |p|&lt;Qs, f(0,p) = f0, otherwise f(0,p) = 0. Only specified species will be given the value. def step_function_distribution(px_grid_size = 20, py_grid_size = 20, pz_grid_size = 20, x_grid_size = 1, y_grid_size = 1, z_grid_size = 1, half_x = 3, half_y = 3, half_z = 3, half_px = 2, half_py = 2, half_pz = 2, fa0 = 0.2, fb0 = 0.2, Qs = 1.): # force spatial grid size to be 1 if x_grid_size != 1 or y_grid_size != 1 or z_grid_size != 1: raise AssertionError(\"make sure that x_grid_size = 1 and y_grid_size == 1 and z_grid_size == 1\") shape_of_distribution_data = [2, x_grid_size, y_grid_size, z_grid_size, px_grid_size,py_grid_size,pz_grid_size] initial_distribution = np.zeros(shape_of_distribution_data) # momentum grid size dpx, dpy, dpz = 2*half_px/px_grid_size, 2*half_py/py_grid_size, 2*half_pz/pz_grid_size # GeV for ipx in range(px_grid_size): for ipy in range(py_grid_size): for ipz in range(pz_grid_size): # central value for each grid px = (ipx+0.5)*dpx - half_px py = (ipy+0.5)*dpy - half_py pz = (ipz+0.5)*dpz - half_pz p = math.sqrt(px**2+py**2+pz**2) if p&lt;Qs: # loop through particle species for p_type in range(2): if p_type == 0: initial_distribution[p_type,0,0,0,ipx,ipy,ipz] = fa0 else: initial_distribution[p_type,0,0,0,ipx,ipy,ipz] = fb0 return initial_distribution Sets the distribution function for particle 0,1. num_momentum_levels = 1 num_particle_species = 2 # iniital distribution function f = {} for i_reg in range(number_regions): f[i_reg] = np.zeros([num_momentum_levels, num_particle_species,\\ nx_o[i_reg], ny_o[i_reg], nz_o[i_reg], npx, npy, npz]) initial_distribution = step_function_distribution(px_grid_size, py_grid_size, pz_grid_size, x_grid_size, y_grid_size, z_grid_size, abs(x_left_bound), abs(y_left_bound), abs(z_left_bound), abs(px_left_bound), abs(py_left_bound), abs(pz_left_bound), fa0 = 0.1, fb0 = 0.4, Qs = 1.) f[0][0][0] = initial_distribution[0]/(2*math.pi)**3 f[0][0][1] = initial_distribution[1]/(2*math.pi)**3 # reshape the distribution function in different regions for i_reg in range(number_regions): f[i_reg] = f[i_reg].reshape([num_momentum_levels, num_particle_species,\\ nx_o[i_reg]*ny_o[i_reg]*nz_o[i_reg]*npx*npy*npz]) Initiate the RBG-Maxwell framework. BEx, BEy, BEz, BBx, BBy, BBz = [0],[0],[0],[0],[0],[0] plasma = Plasma(f,par_list, dt, dt_lower_limit, dt_upper_limit,\\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ int(npx[0]), int(npy[0]), int(npz[0]), half_px, half_py, half_pz,\\ masses, charges, sub_region_relations,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type,\\ num_gpus_for_each_region,\\ hbar, c, lambdax, epsilon0, time_stride_back,\\ num_samples = 100, drift_order = 2,\\ rho_J_method=\"raw\", GPU_ids_for_each_region = [\"1\"]) Initiate the iterative calculation, where n_step represents the number of steps for time iteration, and CT indicate whether or not to compute the collision term (1 represents computation, 0 represents no computation). import time start_time = time.time() for i_time in range(n_step): if i_time%2000 == 0: print('Updating the {}-th time step'.format(i_time)) new_f = plasma.acquire_values(\"Distribution\")[0][0] np.save(\"/data/sunmingyan/collision/RBG-Maxwell\"+str(i_time),new_f) plasma.proceed_one_step(i_time, n_step, processes = {'VT':0., 'DT':0., 'CT':1.},\\ BEx = [0.], BEy = [0.], BEz = [0.], \\ BBx = [0.], BBy = [0.], BBz = [0.]) end_time = time.time() print((end_time-start_time)/3600,'hours') The distribution of particle 0: The distribution of particle 1:"
  },"/2022-08-09-test-large-scale-plasma-term.html": {
    "title": "Test large scale plasma term",
    "keywords": "",
    "url": "/2022-08-09-test-large-scale-plasma-term.html",
    "body": "This procedure primarily discusses the computation of the Vlasov term and the Drift term within the RBG-Maxwell framework. For detailed information regarding the specific structure and content of the program, please refer to Vlasov_Drifit_terms Firstly, import the required packages for the program: import warnings warnings.filterwarnings(\"ignore\") # specify the system from RBG_Maxwell.Collision_database.select_system import which_system plasma_system = 'Ncs_system' which_system(plasma_system) from RBG_Maxwell.Collision_database.Ncs_system.collision_type import collision_type_for_all_species from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion import numpy as np # import the main class Plasma from RBG_Maxwell.Plasma.main import Plasma Next, input the model parameters to create a unit conversion table. Here, the parameters are given in units of the International System of Units (SI). # here we use a pure electron system # the relavant PIC code is given by Jian-Nan Chen # give the quantities in SI # the spatial grid is chosen to be dx=dy=dz=10**(-4) m dx = dy = dz = 1000 # velocity v_max = 1.8*10**6 # charge Q = 1.6*10**(-19) # maximum momentum momentum = 1.674*10**(-19) # the momentum grid is set to be # half_px=half_pz=half_py=momentum npx=npy=npz=20 dpx = dpz = dpy = 2*momentum/npy dp_volume = dpx*dpy*dpz dp = (dpx+dpy+dpz)/3 # time scale dt = 10**(-6) # number of maximum particles in each phase grid n_max = 10000/(npx*npy*npz) # number of averaged particles in each spatial grid nx = ny = nz = 20 n_average = 10000/(nx*ny*nz) E = 10**(-5) B = 10**(-5) masses = 9.3*10**(-26) hbar, c, lambdax, epsilon0 = determine_coefficient_for_unit_conversion(dt, dx, dx*dy*dz, dp, dp_volume,\\ n_max, n_average, v_max, E, B, masses, momentum ) conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) conversion_table_reverse = \\ unit_conversion('LHQCD_to_SI', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) Perform unit conversion on the input parameters and specify the type of ion collision. center = 200*conversion_table['meter'] # time step, and spatial infinitesimals dt, dx, dy, dz = dt*conversion_table['second'], \\ dx*conversion_table['meter'], \\ dy*conversion_table['meter'], \\ dz*conversion_table['meter'] dt_upper_limit = float(10**(-1)*conversion_table['second']) dt_lower_limit = float(10**(-9)*conversion_table['second']) # we have only one type of particle e- num_particle_species = 2 # treat the electron as classical particles particle_type = np.array([0,1]) # masses, charges and degenericies are masses, charges, degeneracy = np.array([9.3*10**(-26)*conversion_table['kilogram'], \\ 4.816*10**(-26)*conversion_table['kilogram']]), \\ np.array([4.8*10**(-19)*conversion_table['Coulomb'],0]),\\ np.array([1,1]) # momentum grids # npx, npy, npz = npx, npy, npz npx, npy, npz = np.array([20,20]),np.array([20,20]),np.array([20,20]) # half_px, half_py, half_pz # momentum range for x and z direction are not import in this case half_px, half_py, half_pz = np.array([1.674*10**(-19)*conversion_table['momentum'],1.674*10**(-19)*conversion_table['momentum']]), \\ np.array([1.674*10**(-19)*conversion_table['momentum'],1.674*10**(-19)*conversion_table['momentum']]),\\ np.array([1.674*10**(-19)*conversion_table['momentum'],1.674*10**(-19)*conversion_table['momentum']]) dpx, dpy, dpz = 2*half_px/npx, 2*half_py/npy, 2*half_pz/npz par_list=[m1**2*c**2, m2**2*c**2, (2*math.pi*hbar)**3, hbar**2*c, d_sigma/(hbar**2)] # load the collision matrix flavor, collision_type, particle_order = collision_type_for_all_species() expected_collision_type = ['2TO2'] Then, you can configure the parallelization of the program and specify the number of GPUs to be used. # number of spatial grids # must be integers and lists # odd numbers are recomended # the maximum spatial gird is limited by CUDA, it's about nx*ny*nz~30000 for each card nx_o, ny_o, nz_o = [nx], [ny], [nz] # value of the left boundary # this is the x_left_bound_o, y_left_bound_o, z_left_bound_o = [-nx/2*dx],\\ [-ny/2*dy],\\ [-nz/2*dz] # number samples gives the number of sample points in MC integration num_samples = 100 # Only specify one spatial region number_regions = 1 # each spatial should use the full GPU, this number can be fractional if many regions are chosen # and only one GPU is available num_gpus_for_each_region = 1 # since only one region is specified, this will be empty sub_region_relations = {'indicator': [[]],\\ 'position': [[]]} # if np.ones are used, the boundaries are absorbing boundaries # if np.zeros are used, it is reflection boundary # numbers in between is also allowed boundary_configuration = {} for i_reg in range(number_regions): bound_x = np.ones([ny_o[i_reg], nz_o[i_reg]]) bound_y = np.ones([nz_o[i_reg], nx_o[i_reg]]) bound_z = np.ones([nx_o[i_reg], ny_o[i_reg]]) boundary_configuration[i_reg] = (bound_x, bound_y, bound_z) Define the initial distribution of particles, primarily specifying the distribution in position space and momentum space. import math npx,npy,npz = 20,20,20 v_collect = np.zeros([npx,npy,npz]) for ipx in range(npx): px = dpx[0]*(ipx+0.5) - half_px[0] for ipy in range(npy): py = dpy[0]*(ipy+0.5) - half_py[0] for ipz in range(npz): pz = dpz[0]*(ipz+0.5) - half_pz[0] # current velocity pnorm = math.sqrt((px**2+py**2+pz**2)) Enorm = math.sqrt(px**2+py**2+pz**2+masses[0]**2*c**2) v = pnorm/Enorm v_collect[ipx, ipy, ipz] = v v_average = masses[0]*\\ 1.87683*10**6*conversion_table['meter']/conversion_table['second']*\\ 1/math.sqrt(1-(1.87683*10**3/c)**2) sigma = 0.2*v_average p_v = 1/math.sqrt(2*math.pi*sigma**2)*np.exp(-(np.array(v_collect-v_average))**2/(2*sigma**2)) p_v = p_v/p_v.sum()*10000 r_collect = np.zeros([nx_o[0],ny_o[0],nz_o[0]]) for ix in range(nx_o[0]): x = ix - int(nx_o[0]/2) for iy in range(ny_o[0]): y = iy - int(ny_o[0]/2) for iz in range(nz_o[0]): z = iz - int(nz_o[0]/2) r = math.sqrt(x**2+y**2+z**2) r_collect[ix, iy, iz] = r sigma = 2 r_v = 1/math.sqrt(2*math.pi*sigma**2)*np.exp(-(np.array(r_collect))**2/(2*sigma**2)) r_v = r_v/r_v.sum() from numba import jit num_momentum_levels = 1 # iniital distribution function f = {} for i_reg in range(number_regions): f[i_reg] = np.zeros([num_momentum_levels, num_particle_species,\\ nx_o[i_reg], ny_o[i_reg], nz_o[i_reg], npx, npy, npz]) # the momentum distribution is a Gaussian function phase_space_volume = dx*dy*dz*dpx*dpy*dpz @jit def setup(npx,npy,npz,nx_o,ny_o,nz_o,f,r_v,p_v): for ipx in range(npx): for ipy in range(npy): for ipz in range(npz): for ix in range(nx_o[0]): for iy in range(ny_o[0]): for iz in range(nz_o[0]): # current velocity f[ix,iy,iz,ipx,ipy,ipz] = r_v[ix,iy,iz]*p_v[ipx,ipy,ipz] return f f[0][0][0] = setup(npx,npy,npz,nx_o,ny_o,nz_o,f[0][0][0],r_v,p_v) The schematic diagram below illustrates the initial position distribution of the particles in the yoz plane: Define the electromagnetic field being used. for i_reg in range(number_regions): f[i_reg] = f[i_reg].reshape([num_momentum_levels, num_particle_species,\\ nx_o[i_reg]*ny_o[i_reg]*nz_o[i_reg]*npx*npy*npz]) ''' We add an external magnetic field of 10 T in the +y direction # ''' BBz = [(1.8*10**(-5))*conversion_table['Tesla']*np.ones(nx_o[0]*ny_o[0]*nz_o[0])] BBx = [(2.9*10**(-5))*conversion_table['Tesla']*np.ones(nx_o[0]*ny_o[0]*nz_o[0])] BBy = [(1*10**(-6))*conversion_table['Tesla']*np.ones(nx_o[0]*ny_o[0]*nz_o[0])] BEx, BEy, BEz = [0],[0],[0] Define the electromagnetic field being used. The parameter ‘drifit_order’ can control the order of differentiation in the calculation. When ‘drifit_order’ is set to 1, the program performs first-order differentiation. When ‘drifit_order’ is set to 2, the program performs second-order differentiation. BEx, BEy, BEz, BBx, BBy, BBz = [0],[0],[0],[0],[0],[0] plasma = Plasma(f,par_list, dt, dt_lower_limit, dt_upper_limit,\\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ int(npx[0]), int(npy[0]), int(npz[0]), half_px, half_py, half_pz,\\ masses, charges, sub_region_relations,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type,\\ num_gpus_for_each_region,\\ hbar, c, lambdax, epsilon0, time_stride_back,\\ num_samples = 100, drift_order = 2,\\ rho_J_method=\"raw\", GPU_ids_for_each_region = [\"1\"]) Initiate the iterative calculation, where n_step represents the number of steps for time iteration, and VT and DT indicate whether or not to compute the Vlasov term and Drift term (1 represents computation, 0 represents no computation). n_step = 10001 number_rho = [] EM = [] charged_rho = [] dis = [] VT= [] DT = [] import time start_time = time.time() for i_time in range(n_step): # if i_time%1000 == 0: # dis.append(plasma.acquire_values(\"Distribution\")) plasma.proceed_one_step(i_time, n_step, processes = {'VT':1., 'DT':1., 'CT':0.},\\ BEx = BEx, BEy = BEy, BEz = BEz, BBx = BBx, BBy = BBy, BBz = BBz) if i_time%500 == 0: print('Updating the {}-th time step'.format(i_time)) number_rho.append(plasma.acquire_values(\"number_rho/J\")) # charged_rho.append(plasma.acquire_values(\"Electric rho/J\")) # EM.append(plasma.acquire_values('EM fields on current region')) end_time = time.time() The results of the calculation, considering only the Drift term, are illustrated in the diagram below: The results of the calculation, incorporating the Vlasov term, are depicted in the diagram below:"
  },"/2022-08-08-test-circle-pure-electron-plasma.html": {
    "title": "Test point expansion of pure electron plasma",
    "keywords": "",
    "url": "/2022-08-08-test-circle-pure-electron-plasma.html",
    "body": "This example is primarily designed to simulate the drifting process of a circle pure electron plasma in the YOZ plane. For detailed information regarding the specific structure and content of the program, please refer to Vlasov_Drifit_terms Firstly, import the required packages for the program: import warnings warnings.filterwarnings(\"ignore\") # specify the system from RBG_Maxwell.Collision_database.select_system import which_system plasma_system = 'Fusion_system' which_system(plasma_system) from RBG_Maxwell.Collision_database.Fusion_system.collision_type import collision_type_for_all_species from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion import numpy as np # import the main class Plasma from RBG_Maxwell.Plasma.main import Plasma Next, input the model parameters to create a unit conversion table. Here, the parameters are given in units of the International System of Units (SI). # here we use a pure electron system # the relavant PIC code is given by Jian-Nan Chen # give the quantities in SI # the spatial grid is chosen to be dx=dy=dz=10**(-4) m dx = dy = 10**(-5) dz = 10**(-5) # velocity v_max = 5*1.87683*10**6 # charge Q = 1.6*10**(-19) # maximum momentum momentum = 10**(-30)*v_max # the momentum grid is set to be # half_px=half_pz=half_py=momentum npy=npz=201 npx=1 dpz = dpy = 2*momentum/npy dpx = 2*momentum dp_volume = dpx*dpy*dpz dp = (dpy+dpz)/2 # time scale dt = 10**(-13) # number of maximum particles in each phase grid n_max = 5*10**(-15)/(1.6*10**(-19))/(npx*npy*npz) # number of averaged particles in each spatial grid nx = 1 ny = nz = 101 n_average = 5*10**(-15)/(1.6*10**(-19))/(nx*ny*nz) E = 10**5 B = 10**(-5) # Now find the coefficient hbar, c, lambdax, epsilon0 = determine_coefficient_for_unit_conversion(dt, dx, dx*dy*dz, dp, dp_volume,\\ n_max, n_average, v_max, E, B) Perform conversions between the International System of Units (SI) and Natural units based on the given parameters. The specific content of the program can be referred to in Unit_Conversion. In addition, we have provided an example to help users better understand the unit conversion program, Test-Conversion. conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) conversion_table_reverse = \\ unit_conversion('LHQCD_to_SI', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) Perform unit conversion on the input parameters and specify the type of ion collision. # time step, and spatial infinitesimals # dt is 10**(-13) s, dx = dy = dz = 10**(-5) m dt, dx, dy, dz = dt*conversion_table['second'], \\ dx*conversion_table['meter'], \\ dy*conversion_table['meter'], \\ dz*conversion_table['meter'] dt_upper_limit = float(10**(-1)*conversion_table['second']) dt_lower_limit = float(10**(-9)*conversion_table['second']) # we have only one type of particle e- num_particle_species = 1 # treat the electron as classical particles particle_type = np.array([0]) # masses, charges and degenericies are masses, charges, degeneracy = np.array([9.11*10**(-31)*conversion_table['kilogram']]), \\ np.array([-1.6*10**(-19)*conversion_table['Coulomb']]),\\ np.array([1.]) # momentum grids npx, npy, npz = npx, npy, npz # half_px, half_py, half_pz # momentum range for x and z direction are not import in this case half_px, half_py, half_pz = np.array([9.11*10**(-31)*v_max*conversion_table['momentum']]), \\ np.array([9.11*10**(-31)*v_max*conversion_table['momentum']]),\\ np.array([9.11*10**(-31)*v_max*conversion_table['momentum']]) dpx, dpy, dpz = 2*half_px/npx, 2*half_py/npy, 2*half_pz/npz par_list=[m1**2*c**2, m2**2*c**2, (2*math.pi*hbar)**3, hbar**2*c, d_sigma/(hbar**2)] # load the collision matrix flavor, collision_type, particle_order = collision_type_for_all_species() expected_collision_type = ['2TO2'] Then, you can configure the parallelization of the program and specify the number of GPUs to be used. # number of spatial grids # must be integers and lists # odd numbers are recomended # the maximum spatial gird is limited by CUDA, it's about nx*ny*nz~30000 for each card nx_o, ny_o, nz_o = [nx], [ny], [nz] # value of the left boundary # this is the x_left_bound_o, y_left_bound_o, z_left_bound_o = [-nx/2*dx],\\ [-ny/2*dy],\\ [-nz/2*dz] # number samples gives the number of sample points in MC integration num_samples = 100 # Only specify one spatial region number_regions = 1 # each spatial should use the full GPU, this number can be fractional if many regions are chosen # and only one GPU is available num_gpus_for_each_region = 1 # since only one region is specified, this will be empty sub_region_relations = {'indicator': [[]],\\ 'position': [[]]} # if np.ones are used, the boundaries are absorbing boundaries # if np.zeros are used, it is reflection boundary # numbers in between is also allowed boundary_configuration = {} for i_reg in range(number_regions): bound_x = np.ones([ny_o[i_reg], nz_o[i_reg]]) bound_y = np.ones([nz_o[i_reg], nx_o[i_reg]]) bound_z = np.ones([nx_o[i_reg], ny_o[i_reg]]) boundary_configuration[i_reg] = (bound_x, bound_y, bound_z) Define the initial distribution of particles, primarily specifying the distribution in position space and momentum space. Momentum distribution of particles import math v_collect = np.zeros([npx,npy,npz]) for ipx in range(npx): px = dpx[0]*(ipx+0.5) - half_px[0] for ipy in range(npy): py = dpy[0]*(ipy+0.5) - half_py[0] for ipz in range(npz): pz = dpz[0]*(ipz+0.5) - half_pz[0] # current velocity pnorm = math.sqrt((px**2+py**2+pz**2)) Enorm = math.sqrt(px**2+py**2+pz**2+masses[0]**2*c**2) v = pnorm/Enorm v_collect[ipx, ipy, ipz] = v v_average = masses[0]*\\ 1.87683*10**6*conversion_table['meter']/conversion_table['second']*\\ 1/math.sqrt(1-(1.87683*10**6/c)**2) sigma = 0.2*v_average p_v = 1/math.sqrt(2*math.pi*sigma**2)*np.exp(-(np.array(v_collect-v_average))**2/(2*sigma**2)) p_v = p_v/p_v.sum()*5*10**(-15)/(1.6*10**(-19)) Position distribution of particles r_collect = np.zeros([nx_o[0],ny_o[0],nz_o[0]]) for ix in range(nx_o[0]): x = ix - int(nx_o[0]/2) for iy in range(ny_o[0]): y = iy - int(ny_o[0]/2) for iz in range(nz_o[0]): z = iz - int(nz_o[0]/2) r = math.sqrt(x**2+y**2+z**2) r_collect[ix, iy, iz] = r sigma = 3 r_v = 1/math.sqrt(2*math.pi*sigma**2)*np.exp(-(np.array(r_collect))**2/(2*sigma**2)) r_v = r_v/r_v.sum() num_momentum_levels = 1 The total particle distribution setting # iniital distribution function f = {} for i_reg in range(number_regions): f[i_reg] = np.zeros([num_momentum_levels, num_particle_species,\\ nx_o[i_reg], ny_o[i_reg], nz_o[i_reg], npx, npy, npz]) # the momentum distribution is a Gaussian function phase_space_volume = dx*dy*dz*dpx*dpy*dpz @jit def setup(npx,npy,npz,nx_o,ny_o,nz_o,f,r_v,p_v): for ipx in range(npx): for ipy in range(npy): for ipz in range(npz): for ix in range(nx_o[0]): for iy in range(ny_o[0]): for iz in range(nz_o[0]): # current velocity f[ix,iy,iz,ipx,ipy,ipz] = r_v[ix,iy,iz]*p_v[ipx,ipy,ipz] return f f[0][0][0] = setup(npx,npy,npz,nx_o,ny_o,nz_o,f[0][0][0],r_v,p_v) # reshape the distribution function in different regions for i_reg in range(number_regions): f[i_reg] = f[i_reg].reshape([num_momentum_levels, num_particle_species,\\ nx_o[i_reg]*ny_o[i_reg]*nz_o[i_reg]*npx*npy*npz]) The schematic diagram below illustrates the initial position distribution of the particles in the yoz plane: Define the electromagnetic field being used. The parameter ‘drifit_order’ can control the order of differentiation in the calculation. When ‘drifit_order’ is set to 1, the program performs first-order differentiation. When ‘drifit_order’ is set to 2, the program performs second-order differentiation. BEx, BEy, BEz, BBx, BBy, BBz = [0],[0],[0],[0],[0],[0] plasma = Plasma(f,par_list, dt, dt_lower_limit, dt_upper_limit,\\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ int(npx[0]), int(npy[0]), int(npz[0]), half_px, half_py, half_pz,\\ masses, charges, sub_region_relations,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type,\\ num_gpus_for_each_region,\\ hbar, c, lambdax, epsilon0, time_stride_back,\\ num_samples = 100, drift_order = 2,\\ rho_J_method=\"raw\", GPU_ids_for_each_region = [\"1\"]) Initiate the iterative calculation, where n_step represents the number of steps for time iteration, and VT and DT indicate whether or not to compute the Vlasov term and Drift term (1 represents computation, 0 represents no computation). n_step = 5001 number_rho = [] EM = [] charged_rho = [] dis = [] VT= [] DT = [] import time start_time = time.time() for i_time in range(n_step): # if i_time%1000 == 0: # dis.append(plasma.acquire_values(\"Distribution\")) plasma.proceed_one_step(i_time, n_step, processes = {'VT':0., 'DT':1., 'CT':0.},\\ BEx = BEx, BEy = BEy, BEz = BEz, BBx = BBx, BBy = BBy, BBz = BBz) if i_time%500 == 0: print('Updating the {}-th time step'.format(i_time)) number_rho.append(plasma.acquire_values(\"number_rho/J\")) # charged_rho.append(plasma.acquire_values(\"Electric rho/J\")) # EM.append(plasma.acquire_values('EM fields on current region')) end_time = time.time() Plotting the results using matplotlib : # spatial distribution import matplotlib.pyplot as plt xi, yi = np.mgrid[1:102:1,1:102:1] fig, axes = plt.subplots(ncols=5, nrows=2, figsize = (15,5)) for jj in range(2): for kk in range(5): axes[jj,kk].pcolormesh(xi, yi, number_rho[(jj*5+kk)][0][0].reshape([nx_o[0],ny_o[0],nz_o[0]])[0]) The calculated result of drift term using second-order differentiation is shown below:"
  },"/2022-08-07-test-pure-electron-plasma.html": {
    "title": "Test pure electron plasma",
    "keywords": "",
    "url": "/2022-08-07-test-pure-electron-plasma.html",
    "body": "This example is primarily designed to simulate the drifting process of a pure electron plasma in the YOZ plane. In order to accurately calculate the drift term, the RBG-Maxwell incorporates both first-order and second-order differentials. For detailed information regarding the specific structure and content of the program, please refer to Vlasov_Drifit_terms Firstly, import the required packages for the program: import warnings warnings.filterwarnings(\"ignore\") # specify the system from RBG_Maxwell.Collision_database.select_system import which_system plasma_system = 'Fusion_system' which_system(plasma_system) from RBG_Maxwell.Collision_database.Fusion_system.collision_type import collision_type_for_all_species from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion import numpy as np # import the main class Plasma from RBG_Maxwell.Plasma.main import Plasma Next, input the model parameters to create a unit conversion table. Here, the parameters are given in units of the International System of Units (SI). # give the quantities in SI # the spatial grid is chosen to be dx=dy=dz=10**(-4) m dx = dy = 10**(-5) dz = 1. # velocity is roughly 10**(6) m/s v = 5*10**6 # charge Q = 1.6*10**(-19) # momentum is roughly 10**(-30)kg*10**7m/s momentum = 10**(-23) # the momentum grid is set to be # npy=100, npx=npz=1, half_px=half_pz=half_py~10**(-23) # hence dpy~10**(-26), dpx and dpz have no effect dp = (10**(-25)*10**(-23)*10**(-23))**(1/3) # the total number of particles are 5*10**(-13)/(1.6*10**(-19)) # put these particles in 71 spatial grids in z direction # in 201 spatial grids in y direction # and 100 momentum grids # in each phase grid we have dn = 21.89755448111554 # the average value of distribution is roughly dn = 0.2189755448111554 f = dn/(dp**3*dx*dy*dz) df = f # time scale dt = 10**(-13) E = 0 B = 10 # Now find the coefficient hbar, c, lambdax, epsilon0 = determine_coefficient_for_unit_conversion(dt, dx, dx*dy*dz, dp, dp**3,\\ 5*10**(-14)/(1.6*10**(-19)), dn, v, E, B) Perform conversions between the International System of Units (SI) and Natural units based on the given parameters. The specific content of the program can be referred to in Unit_Conversion. In addition, we have provided an example to help users better understand the unit conversion program, Test-Conversion. conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) conversion_table_reverse = \\ unit_conversion('LHQCD_to_SI', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) Perform unit conversion on the input parameters and specify the type of ion collision. # time step, and spatial infinitesimals # dt is 10**(-13) s, dx = dy = dz = 10**(-5) m dt, dx, dy, dz = 10**(-13)*conversion_table['second'], \\ 10**(-5)*conversion_table['meter'], \\ 10**(-5)*conversion_table['meter'], \\ 10**(-5)*conversion_table['meter'] dt_upper_limit = float(10**(-1)*conversion_table['second']) dt_lower_limit = float(10**(-9)*conversion_table['second']) # we have only one type of particle e- num_particle_species = 1 # treat the electron as classical particles particle_type = np.array([0]) # masses, charges and degenericies are masses, charges, degeneracy = np.array([9.11*10**(-31)*conversion_table['kilogram']]), \\ np.array([-1.6*10**(-19)*conversion_table['Coulomb']]),\\ np.array([1.]) # momentum grids npx, npy, npz = 1, 201, 1 # half_px, half_py, half_pz # momentum range for x and z direction are not import in this case half_px, half_py, half_pz = np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]), \\ np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]),\\ np.array([9.11*10**(-31)*5*10**6*conversion_table['momentum']]) dpx, dpy, dpz = 2*half_px/npx, 2*half_py/npy, 2*half_pz/npz par_list=[m1**2*c**2, m2**2*c**2, (2*math.pi*hbar)**3, hbar**2*c, d_sigma/(hbar**2)] # load the collision matrix flavor, collision_type, particle_order = collision_type_for_all_species() expected_collision_type = ['2TO2'] Then, you can configure the parallelization of the program and specify the number of GPUs to be used. # number of spatial grids # the maximum spatial gird is limited by CUDA, it's about nx*ny*nz~30000 for each card nx_o, ny_o, nz_o = [1], [251], [111] # value of the left boundary # this is the x_left_bound_o, y_left_bound_o, z_left_bound_o = [-0.5*dx],\\ [-125.5*dy],\\ [-55.5*dz] # number samples gives the number of sample points in MC integration num_samples = 100 # Only specify one spatial region number_regions = 1 # each spatial should use the full GPU, this number can be fractional if many regions are chosen # and only one GPU is available num_gpus_for_each_region = 0.1 # since only one region is specified, this will be empty sub_region_relations = {'indicator': [[]],\\ 'position': [[]]} # if np.ones are used, the boundaries are absorbing boundaries # if np.zeros are used, it is reflection boundary # numbers in between is also allowed boundary_configuration = {} for i_reg in range(number_regions): bound_x = np.ones([ny_o[i_reg], nz_o[i_reg]]) bound_y = np.ones([nz_o[i_reg], nx_o[i_reg]]) bound_z = np.ones([nx_o[i_reg], ny_o[i_reg]]) boundary_configuration[i_reg] = (bound_x, bound_y, bound_z) Define the initial distribution of particles, primarily specifying the distribution in position space and momentum space. The total number of particles is 510(-13)/(1.6*10(-19)) ~ 31249999.999999996. Put these particles in 101 grids, the number density of the particles is 31249999.999999996/(101dxdydz) ~ 756837.0957070973 -&gt; Delta_N/Delta_V. The particles only possess the momentum region of size dpxdpydpz, hence the distribution function at each phase space grid is 756837.0957070973/(dpxdpydpz) ~ 756837.0957070973/(2half_px/npx2half_py/npy2*half_pz/npz) ~ 1234.63197049 num_momentum_levels = 1 # iniital distribution function f = {} for i_reg in range(number_regions): f[i_reg] = np.zeros([num_momentum_levels, num_particle_species,\\ nx_o[i_reg], ny_o[i_reg], nz_o[i_reg], npx, npy, npz]) # The initial velocity of the electrons is 1.87683*10**6 m/s, corresponds to the momentum value # 9.11*10**(-31)*1.87683*10**6*conversion_table['momentum'] ~ 408.770512. # The following code specifies the momentum grid index dpy = 2*half_py/npy a = 9.11*10**(-31)*1.87683*10**6*conversion_table['momentum'] ipy = [i for i in range(npy) if (-half_py+dpy*(i-0.5))&lt;=a&lt;=(-half_py+dpy*(i+1))][0] dn_dv = 5*10**(-14)/(1.6*10**(-19))/(101*dx*dy*dz*dpx*dpy*dpz) # e-, the first two indices correspond to num_momentum_levels=1, and num_particle_types=1 f[0][0, 0, 0,9,5:106,0,ipy,0] = dn_dv # reshape the distribution function in different regions for i_reg in range(number_regions): f[i_reg] = f[i_reg].reshape([num_momentum_levels, num_particle_species,\\ nx_o[i_reg]*ny_o[i_reg]*nz_o[i_reg]*npx*npy*npz]) The schematic diagram below illustrates the initial position distribution of the particles in the yoz plane: Define the electromagnetic field being used. The parameter ‘drifit_order’ can control the order of differentiation in the calculation. When ‘drifit_order’ is set to 1, the program performs first-order differentiation. When ‘drifit_order’ is set to 2, the program performs second-order differentiation. ''' We add an external magnetic field of 10 T in the +y direction ''' BBy = [10*conversion_table['Tesla']*np.ones(nx_o[0]*ny_o[0]*nz_o[0])] BEx, BEy, BEz, BBx, BBz = [0],[0],[0],[0],[0] plasma = Plasma(f,par_list, dt, dt_lower_limit, dt_upper_limit,\\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ int(npx[0]), int(npy[0]), int(npz[0]), half_px, half_py, half_pz,\\ masses, charges, sub_region_relations,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type,\\ num_gpus_for_each_region,\\ hbar, c, lambdax, epsilon0, time_stride_back,\\ num_samples = 100, drift_order = 2,\\ rho_J_method=\"raw\", GPU_ids_for_each_region = [\"1\"]) Initiate the iterative calculation, where n_step represents the number of steps for time iteration, and VT and DT indicate whether or not to compute the Vlasov term and Drift term (1 represents computation, 0 represents no computation). n_step = 10001 number_rho = [] EM = [] charged_rho = [] dis = [] VT= [] DT = [] import time start_time = time.time() for i_time in range(n_step): # if i_time%1000 == 0: # dis.append(plasma.acquire_values(\"Distribution\")) plasma.proceed_one_step(i_time, n_step, processes = {'VT':1., 'DT':1., 'CT':0.},\\ BEx = BEx, BEy = BEy, BEz = BEz, BBx = BBx, BBy = BBy, BBz = BBz) if i_time%1000 == 0: print('Updating the {}-th time step'.format(i_time)) number_rho.append(plasma.acquire_values(\"number_rho/J\")) charged_rho.append(plasma.acquire_values(\"Electric rho/J\")) EM.append(plasma.acquire_values('EM fields on current region')) end_time = time.time() Plotting the results using matplotlib : # spatial distribution import matplotlib.pyplot as plt xi, yi = np.mgrid[1:252:1,1:112:1] fig, axes = plt.subplots(ncols=5, nrows=2, figsize = (15,5)) for jj in range(2): for kk in range(5): axes[jj,kk].pcolormesh(xi, yi, number_rho[(jj*5+kk+1)][0][0].reshape([nx_o[0],ny_o[0],nz_o[0]])[0]) The calculated result of drift term using second-order differentiation is shown below:"
  },"/2022-08-05-test-conversion.html": {
    "title": "Test Conversion",
    "keywords": "",
    "url": "/2022-08-05-test-conversion.html",
    "body": "This procedure primarily discusses the unit conversion within the RBG-Maxwell framework. For detailed information regarding the specific structure and content of the program, please refer to Conversion Firstly, import the required packages for the program: from RBG_Maxwell.Unit_conversion.main import determine_coefficient_for_unit_conversion, unit_conversion Next, input the parameters to be converted. Here, the parameters are given in units of the International System of Units (SI). dx = dy = dz = 1000 # velocity v_max = 1.8*10**6 # maximum momentum momentum = 1.674*10**(-19) # the momentum grid is set to be # half_px=half_pz=half_py=momentum npx=npy=npz=20 dpx = dpz = dpy = 2*momentum/npy dp_volume = dpx*dpy*dpz dp = (dpx+dpy+dpz)/3 # time scale dt = 10**(-6) # number of maximum particles in each phase grid n_max = 10000/(npx*npy*npz) # number of averaged particles in each spatial grid nx = ny = nz = 20 n_average = 10000/(nx*ny*nz) E = 10**(-5) B = 10**(-5) masses = 9.3*10**(-26) To prevent the occurrence of excessively large values during the calculation process due to unit conversions, the program includes the “determine_coefficient_for_unit_conversion” function. This function ensures that the conversion process does not result in excessively large parameters. If the input parameters cannot be properly regulated to a lower level, the program will throw an error and suggest adjusting the input parameters. hbar, c, lambdax, epsilon0 = determine_coefficient_for_unit_conversion(dt, dx, dx*dy*dz, dp, dp_volume,n_max, n_average, v_max, E, B, masses, momentum ) Then, when the parameters hbar, c, lambdax, and epsilon0 are obtained, the program calls a function to establish a unit conversion table. Of course, users can also define the aforementioned parameters themselves and perform the unit conversion. conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) conversion_table_reverse = \\ unit_conversion('LHQCD_to_SI', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) Finally, you can utilize the unit conversion table to perform unit conversions. SI units -&gt; Free units meter_text = 200*conversion_table['meter'] masses_text = 9.3*10**(-26)*conversion_table['kilogram'] meter_text : 47815189.40719678 masses_text : 2223415208.663215 ​ Free units -&gt; SI units meter_text = 47815189.40719678*conversion_table_reverse['TO_meter'] masses_text = 2223415208.663215*conversion_table_reverse['TO_kilogram'] meter_text : 200 masses_text : 9.3*10**(-26)"
  },"/2022-08-01-Example.html": {
    "title": "Example",
    "keywords": "",
    "url": "/2022-08-01-Example.html",
    "body": "This section aims to provide users with a deeper understanding of the entire RBG-Maxwell framework through two simple examples. Firstly, the first example focuses on unit conversion of parameters within the RBG-Maxwell framework. Test Conversion Secondly, We use a two dimensional (2D) pure electron plasma system to test the Drift and Vlasov term. Test_pure_electron_plasma Thirdly, We use a two dimensional (2D) circle pure electron plasma system to test the Drifit term. Test_circle_pure_electron_plasma Fourthly, We use the three dimensional (3D) large-scale plasmas to test the Drifit and Vlasov term. Test large_scale_plasma term Finally, We use two different particles to test the collision term Test_collision_term"
  },"/jekyll/2022-07-13-Externel-forces.html": {
    "title": "Externel-forces",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-13-Externel-forces.html",
    "body": "The program primarily calculates the long-range electromagnetic force in the Vlasov term of the Boltzmann equation. External_forces（） The program primarily initializes the long-range electromagnetic force def External_forces(masses, charges,\\ total_phase_grids, num_particle_species, \\ npx,npy,npz,nx,ny,nz, \\ half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, \\ blockspergrid_total_phase, threadsperblock, number_momentum_levels,\\ Ex, Ey, Ez, Bx, By, Bz): # allocate a space in GPU to save the electromagnetic forces Fx = cupy.zeros([number_momentum_levels, num_particle_species, total_phase_grids]) Fy = cupy.zeros([number_momentum_levels, num_particle_species, total_phase_grids]) Fz = cupy.zeros([number_momentum_levels, num_particle_species, total_phase_grids]) EM_force_kernel[blockspergrid_total_phase, threadsperblock]\\ (Fx, Fy, Fz, masses, charges,\\ total_phase_grids, num_particle_species, \\ npx,npy,npz,nx,ny,nz, \\ half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, \\ Ex, Ey, Ez, Bx, By, Bz, number_momentum_levels, c) return Fx, Fy, Fz EM_force_kernel() The function primarily calculates the long-range electromagnetic force； First, we establish a one-to-one correspondence between the GPU block indices and the position space and momentum space； i_grid = cuda.grid(1) if i_grid &lt; total_grid: # convert one-d index into six-d ipz = i_grid%npz ipz_rest = i_grid//npz ipy = ipz_rest%npy ipy_rest = ipz_rest//npy ipx = ipy_rest%npx ipx_rest = ipy_rest//npx iz = ipx_rest%nz iz_rest = ipx_rest//nz iy = iz_rest%ny iy_rest = iz_rest//ny ix = iy_rest%nx i_s = iz + iy*nz + ix*nz*ny Next, we perform calculations for the long-range electromagnetic force ： for p_type in range(num_of_particle_types): mp_squared = masses[p_type]**2 # loop through all momentum levels for i_level in range(number_momentum_levels): px = ((ipx+0.5)*dpx[p_type] - half_px[p_type])/(npx**i_level) py = ((ipy+0.5)*dpy[p_type] - half_py[p_type])/(npy**i_level) pz = ((ipz+0.5)*dpz[p_type] - half_pz[p_type])/(npz**i_level) charge = charges[p_type] # p0 for current grid p0 = math.sqrt(mp_squared*c**2+px**2+py**2+pz**2) # vx, vy, vz vx = 0. vy = 0. vz = 0. if p0 &gt; 10**(-19): vx = c*px/p0 vy = c*py/p0 vz = c*pz/p0 if abs(px) &lt; 0.5*dpx[p_type]: vx = 0. if abs(py) &lt; 0.5*dpy[p_type]: vy = 0. if abs(pz) &lt; 0.5*dpz[p_type]: vz = 0. Fx[i_level,p_type,i_grid] = charge*(Efx + (vy*Bfz - vz*Bfy)) Fy[i_level,p_type,i_grid] = charge*(Efy + (vz*Bfx - vx*Bfz)) Fz[i_level,p_type,i_grid] = charge*(Efz + (vx*Bfy - vy*Bfx))"
  },"/jekyll/2022-07-12-Macro-quantities.html": {
    "title": "Macro_quantities",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-12-Macro-quantities.html",
    "body": "The program primarily defines the charge density (ρ) and current density (J). charged_density（） The program primarily initializes the charge density and current density for electrons ： Since the particle type is already specified as electrons, the initialization process focuses solely on defining the position space and momentum space. def charged_density(f, num_particle_species, total_spatial_grids, \\ masses, charges, degeneracy, \\ total_phase_grids, momentum_volume_element, npx, npy, npz, \\ nx, ny, nz, half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, num_momentum_levels,\\ blockspergrid_total_phase, threadsperblock): electric_rho = cupy.zeros([total_spatial_grids]) electric_Jx = cupy.zeros([total_spatial_grids]) electric_Jy = cupy.zeros([total_spatial_grids]) electric_Jz = cupy.zeros([total_spatial_grids]) electric_rho_J_kernel[blockspergrid_total_phase, threadsperblock]\\ (f, electric_rho, electric_Jx, electric_Jy, electric_Jz, \\ masses, charges, degeneracy,\\ total_phase_grids, num_particle_species, total_spatial_grids,\\ momentum_volume_element, npx, npy, npz, nx, ny, nz, \\ half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, num_momentum_levels) return electric_rho, electric_Jx, electric_Jy, electric_Jz electric_rho_J_kernel() The function primarily calculates the charge density and current density for electrons. First, it associates the GPU block index with the position and momentum of the particles： i_grid = cuda.grid(1) if i_grid &lt; total_grid: # convert one-d index into six-d ipz = i_grid%npz ipz_rest = i_grid//npz ipy = ipz_rest%npy ipy_rest = ipz_rest//npy ipx = ipy_rest%npx ipx_rest = ipy_rest//npx iz = ipx_rest%nz iz_rest = ipx_rest//nz iy = iz_rest%ny iy_rest = iz_rest//ny ix = iy_rest%nx i_s = iz + iy*nz + ix*nz*ny Then, it calculates the charge density ： The particle type loop is necessary because there are multiple electrons with different masses, so their contributions are summed. for p_type in range(num_of_particle_types): # distribution function multiplied by volume modified_f = f_x_p_t[0, p_type, i_grid]*momentum_volume_element[p_type]*charges[p_type] # if modified_f is less than the numerical accuracy, turn it into 0 if abs(modified_f) &lt; 10**(-19): modified_f = 0. # rho at each phase space point # rho only considers the 0-th momentum level cuda.atomic.add(rho, i_s, modified_f) Finally, it calculates the current density： for p_type in range(num_of_particle_types): # distribution function multiplied by volume modified_f = f_x_p_t[0, p_type, i_grid]*momentum_volume_element[p_type]*charges[p_type] # if modified_f is less than the numerical accuracy, turn it into 0 if abs(modified_f) &lt; 10**(-19): modified_f = 0. cuda.atomic.add(rho, i_s, modified_f) px = ((ipx+0.5)*dpx[p_type] - half_px[p_type]) py = ((ipy+0.5)*dpy[p_type] - half_py[p_type]) pz = ((ipz+0.5)*dpz[p_type] - half_pz[p_type]) # energy for current grid mp_squared = masses[p_type]**2 # p0 for current grid p0 = math.sqrt(mp_squared*c**2+px**2+py**2+pz**2) # vx, vy, vz vx = 0. vy = 0. vz = 0. if p0 &gt; 10**(-19): vx = c*px/p0 vy = c*py/p0 vz = c*pz/p0 if abs(px) &lt; 0.5*dpx[p_type]: vx = 0. if abs(py) &lt; 0.5*dpy[p_type]: vy = 0. if abs(pz) &lt; 0.5*dpz[p_type]: vz = 0. fvx = modified_f*vx fvy = modified_f*vy fvz = modified_f*vz # if fv is less than the numerical accuracy, turn it into 0 if abs(fvx) &lt; 10**(-19): fvx = 0. if abs(fvy) &lt; 10**(-19): fvy = 0. if abs(fvz) &lt; 10**(-19): fvz = 0. cuda.atomic.add(Jx, i_s, fvx) cuda.atomic.add(Jy, i_s, fvy) cuda.atomic.add(Jz, i_s, fvz)"
  },"/jekyll/2022-07-11-Straitified-time-update.html": {
    "title": "Straitified_time_updation",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-11-Straitified-time-update.html",
    "body": "The program primarily focuses on checking and updating the single-particle distribution function. check_legacy_of_distributions（） The function is mainly responsible for checking the single-particle distribution function； There are two input parameters: distribution - representing the single-particle distribution function, and particle_type - indicating the type of particle. To ensure thermal equilibrium in the system, fermions follow the Fermi-Dirac distribution, which has values ranging from 0 to 1. length = len(degeneracy) # loop thorugh the particle types for i_type in range(length): # take the minimum value of the distribution f_min = cupy.amin(distribution[:,i_type]) # if the distribution is smaller than zero, return False # very small statistical negative distributiona are legal if f_min &lt; -10**(-19): position = cupy.argmin(cupy.array(distribution[:,i_type])) return 0,'f_min',f_min,i_type,position # for fermions we need to find the maximum value of the distributions as well if particle_type[i_type] == 1: f_max = cupy.amax(distribution[:,i_type]) # return False if the maximum value is larger than g*1/(2*math.pi*hbar)**3 for fermions if f_max &gt; degeneracy[i_type]*1/(2*math.pi*hbar)**3: position = cupy.argmin(cupy.array(distribution[:,i_type])) return 0,'f_max',f_max,i_type,position # if no issues are found, return True return 1,0,0,0,0 update_the_dt（） To prevent users from encountering problems during the process of setting dt, the program will automatically adjust dt based on the simulation results. If negative particle distribution occurs during the calculation process, the program will return to the distribution before time_stride_back and decrease dt. If there is no negative particle distribution in 100 time steps of the calculation, the program will increase dt to reduce computation time. self.change_index = self.change_index + 1 if any(whether_terminate) == 0: self.change_index = 0 self.change_time(self.dt_upper_limit, self.dt_lower_limit, 0, 1) print(\"Since the f &lt; 0, we reduce dt. The dt is: \",self.global_dt) self.back_to_previous = 1 del self.dt_list[-self.time_stride_back:] else: #exchange bundaries when the distributions are legel self.back_to_previous = 0 # exchange the boundaries after evaluation if self.number_regions &gt; 1: self.exchange_boundaries() # exchange EM fields for Vlasov term if processes['VT']&gt;0.5: self.exchange_EM_fields() if self.change_index == 100: self.change_index = 0 self.change_time(self.dt_upper_limit, self.dt_lower_limit, 1, 0) if abs(self.global_dt - self.dt_upper_limit) &gt; 10**(-13): print(\"We have increased dt to inhence performance. The dt is: \",self.global_dt) self.dt_list.append(self.global_dt) change_time（） The program primarily changes the value of dt based on the input parameters. The input parameters for the program are as follows: up_line: Upper limit of dt; down_line: Lower limit of dt The variables “up” and “down” serve as indicators for whether dt should be increased or decreased. When up=1, it indicates that dt should be increased, and when down=1, it indicates that dt should be decreased. def change_time(self,up_line, down_line, up, down): if up == 1: self.global_dt = self.global_dt*10 if down == 1: self.global_dt = self.global_dt/10 if self.global_dt &lt; down_line: raise AssertionError(\"The dt has reached the lower limit! Try use different configuration, e.g. d_sigma\") if self.global_dt &gt; up_line: self.global_dt = self.global_dt/10"
  },"/jekyll/2022-07-10-Conversion.html": {
    "title": "Unit_Conversion",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-10-Conversion.html",
    "body": "The main purpose of this program is to facilitate the conversion between the International System of Units (SI) and the Natural Units (NU). ​ I will briefly explain the methods for converting between unit systems and the definition of initial values, and provide a conversion table from SI to NU units. Conversion Methods and Initial Values Some initial values defined in the International System of Units (SI) ： Based on these initial values, we can start the conversion between different units ； Let’s take the conversion of meters (m) as an example； First, we identify the variables related to meters in the initial values and eliminate other variables except for energy： ​ Next, we adjust and simplify the equations to extract the desired units of length ： The final value of 1m in the natural unit system is obtained; using the above method to convert common units, the results are as follows : Conversion tables between the natural system of units and the International System of Units ： Methods for calling specific functions： The function is divided into three parts: conversion from NU to SI, conversion from SI to NU, and the search for conversion parameters. The conversion from SI to NU. where coef_J_to_E = λ； epsilon0 = ε ； k = kb; hbar = h x = coef_J_to_E conversion_dictionary = \\ {'Joules':1/x,'meter': 3.16304*10**(25)*hbar*c*x,'second':9.48253*10**(33)*hbar*x,\\ 'kilogram':8.98752*10**(16)/(x*c**2),'Kelvin':1.38065*10**(-23)/(x*k),\\ 'Ampere':1.99347*10**(-16)*math.sqrt(c*epsilon0)/(x*math.sqrt(hbar)),\\ 'Coulomb':1.89032*10**(18)*math.sqrt(hbar*c*epsilon0),\\ 'Tesla':5.01397*10**(-36)/(x**2*hbar**(3/2)*c**(5/2)*math.sqrt(epsilon0)),\\ 'Volt/m':1.67248*10**(-44)/(x**2*hbar**(3/2)*c**(3/2)*math.sqrt(epsilon0)), \\ 'momentum':2.99792*10**8/(x*c),'force':3.16152*10**-26/(x**2*hbar*c),\\ 'unit charge': 0.302862*math.sqrt(hbar*c*epsilon0)} The conversion from NU to SI. if conversion_direction == 'LHQCD_to_SI': conversion_dictionaryy = \\ {'TO_Joules':1/conversion_dictionary['Joules'],'TO_meter': 1/conversion_dictionary['meter'],\\ 'TO_second':1/conversion_dictionary['second'],'TO_kilogram':1/conversion_dictionary['kilogram'],\\ 'TO_Kelvin':1/conversion_dictionary['Kelvin'],'TO_Ampere':1/conversion_dictionary['Ampere'],\\ 'TO_Coulomb':1/conversion_dictionary['Coulomb'],'TO_Tesla':1/conversion_dictionary['Tesla'],\\ 'TO_Volt/m':1/conversion_dictionary['Volt/m'], 'TO_momentum':1/conversion_dictionary['momentum'],\\ 'TO_force':1/conversion_dictionary['force'],'TO_unit charge':1/conversion_dictionary['unit charge']} return conversion_dictionaryy The selection of conversion parameters. def determine_coefficient_for_unit_conversion(dt, dx, dx_volume, dp, dp_volume,\\ n_max, n_average, v_max, E, B): print('Searching for proper scaling parameters...') print('This may take several minutes.') for i in range(-35,35,1): hbar = 10**i for j in range(9,-9,-1): c = 10**j for k in range(-30,30,1): lambdax = 10**k for h in range(-13,13,1): epsilon0 = 10**h try: conversion_table = \\ unit_conversion('SI_to_LHQCD', coef_J_to_E=lambdax, hbar=hbar, c=c, k=1., epsilon0=epsilon0) dt_converted = dt*conversion_table['second'] dx_converted = dx*conversion_table['meter'] dp_converted = dp*conversion_table['momentum'] dx_volum_converted = dx_volume*conversion_table['meter']**3 dp_volume_converted = dp_volume*conversion_table['momentum']**3 f_max_converted = n_max/(dx_volum_converted*dp_volume_converted) unit_charge_converted = 1.6*10**(-19)*conversion_table['Coulomb'] v_max_converted = v_max*conversion_table['meter']/conversion_table['second'] rho_max_converted = unit_charge_converted*\\ n_average/dx_volum_converted J_max_converted = rho_max_converted*v_max_converted E_coef_converted = 1/(4*math.pi*epsilon0)*rho_max_converted*dx +\\ E*conversion_table['Volt/m'] B_coef_converted = 1/(4*math.pi*epsilon0*c**2)*J_max_converted*dx+\\ B*conversion_table['Tesla'] F_converted = unit_charge_converted*(E_coef_converted+v_max_converted*B_coef_converted) if 10**(-10)&lt;abs(E_coef_converted)&lt;10**10 and\\ 10**(-10)&lt;abs(B_coef_converted)&lt;10**10 and\\ 10**(-10)&lt;(1/dt_converted)&lt;10**10 and \\ 10**(-10)&lt;abs((F_converted/dp_converted)&lt;10**10 and \\ 10**(-10)&lt;(v_max_converted/dx_converted))&lt;10**10 and \\ 10**(-5)&lt;rho_max_converted&lt;10**5 and \\ 10**(-5)&lt;J_max_converted&lt;10**5 and\\ 10**(-10)&lt;f_max_converted&lt;10**10: return hbar, c, lambdax, epsilon0 except: pass"
  },"/jekyll/2022-07-09-EMsolver.html": {
    "title": "EMsolver",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-09-EMsolver.html",
    "body": "The program primarily solves the Jefimenko equations for different charge densities and current densities.； The objective is to obtain the electromagnetic field parameters for varying charge densities and current densities. To understand the background and principles of the application of the program you can refer to the following article JefiGPU: Jefimenko’s Equations on GPU ​ Advantages of the program The Jefimenko equations are efficiently processed using CUDA for fast parallel computation. Structure of the program Class EBsolver（） init() update_rho_J（） Jefimenko_solver（） Class EMsolver（） init() terminate（） Jefimenko_solver（） acquire_EB_field() areal_position（） generate_rho_J() real_position() copy_new_rho_J_to_GPU() retarded_time_index() r_distance() The overall logic of the program can be described as follows: EMsolver（） Main class for solving E and B from Jefimenko’s equations. The calculated rho and J are always stored as the self.data. The Params: ​ len_time_snapshots: int, the maximum time sequence that can be stored in GPU memory ​ x_grid_size_o, y_grid_size_o, z_grid_size_o: number of grid sizes in the obervation region ​ x_grid_size_s, y_grid_size_s, z_grid_size_s: number of grid sizes in the source region ​ dx_o, dy_o, dz_o: infinitesimal difference of the spatial coordinates in the observation region ​ dx_s, dy_s, dz_s: infinitesimal difference of the spatial coordinates in the source region ​ x_left_boundary_o, y_left_boundary_o, z_left_boundary_o: the left boundary of the observation region ​ x_left_boundary_s, y_left_boundary_s, z_left_boundary_s: the left boundary of the source region ​ dt: time step, epsilon0: the numerical value of epsilon0 used in FU (Flexible Unit), ​ c: the numerical value of c used in FU (Flexible Unit) class EMsolver(): def __init__(self, \\ len_time_snapshots, \\ x_grid_size_o, y_grid_size_o, z_grid_size_o, \\ x_grid_size_s, y_grid_size_s, z_grid_size_s, \\ dx_o, dy_o, dz_o, x_left_boundary_o, y_left_boundary_o, z_left_boundary_o, \\ dx_s, dy_s, dz_s, x_left_boundary_s, y_left_boundary_s, z_left_boundary_s, \\ dt, epsilon0, c): # save the variables in the class self.len_time_snapshots = len_time_snapshots self.dx_o, self.dy_o, self.dz_o = dx_o, dy_o, dz_o self.dx_s, self.dy_s, self.dz_s = dx_s, dy_s, dz_s self.x_left_boundary_o, self.y_left_boundary_o, self.z_left_boundary_o = x_left_boundary_o, y_left_boundary_o, z_left_boundary_o self.x_left_boundary_s, self.y_left_boundary_s, self.z_left_boundary_s = x_left_boundary_s, y_left_boundary_s, z_left_boundary_s self.x_grid_size_o, self.y_grid_size_o, self.z_grid_size_o = x_grid_size_o, y_grid_size_o, z_grid_size_o self.x_grid_size_s, self.y_grid_size_s, self.z_grid_size_s = x_grid_size_s, y_grid_size_s, z_grid_size_s self.dt = dt self.epsilon0 = epsilon0 self.c = c # total grid numbers and total time ticks in GPU self.total_grid_o = x_grid_size_o*y_grid_size_o*z_grid_size_o self.total_grid_s = x_grid_size_s*y_grid_size_s*z_grid_size_s self.all_grids = self.total_grid_o*self.total_grid_s # Configure the blocks self.threadsperblock = 32 # configure the grids self.blockspergrid_o = (self.total_grid_o + (self.threadsperblock - 1)) // self.threadsperblock self.blockspergrid_s = (self.total_grid_s + (self.threadsperblock - 1)) // self.threadsperblock self.blockspergrid_all = (self.all_grids + (self.threadsperblock - 1)) // self.threadsperblock # define device array of rho and J with zero initial values of the source region self.rho_GPU, self.Jx_GPU, self.Jy_GPU, self.Jz_GPU = \\ (cupy.zeros([len_time_snapshots, self.total_grid_s], dtype=np.float64) for _ in range(4)) # coefficient for E and B when doing integration in the source region self.coeff_E = 1/(4*math.pi*epsilon0)*dx_s*dy_s*dz_s self.coeff_B = -1/(4*math.pi*epsilon0*c**2)*dx_s*dy_s*dz_s # store the sequences of the time steps chosen self.dt_series = cupy.zeros([len_time_snapshots]) self.dt_list = [] # time tick self.time_tick = 0 # accumulated time steps from the current dt till the previous self.accumu_dt_series = cupy.zeros([len_time_snapshots]) self.accumu_dt_index = cupy.zeros([len_time_snapshots], dtype=np.int64) update_rho_J（） The function primarily calculates the time index and saves the current charge density during the time iteration process. It consists of two sub-functions. def update_rho_J(self, rho, Jx, Jy, Jz): # i_time: int, index at which to copy the data # i_round: i_step = i_rounds*len_time_snapshots + i_time self.i_round, self.i_time = time_index_in_GPU(self.time_tick, self.len_time_snapshots) self.t = self.time_tick*self.dt self.time_tick += 1 # send these data to GPU rho, Jx, Jy, Jz = (cupy.asarray(i) for i in [rho, Jx, Jy, Jz]) # copy newly calculated rho and J to GPU copy_new_rho_J_to_GPU[self.blockspergrid_s, self.threadsperblock](self.i_time, rho, Jx, Jy, Jz, \\ self.rho_GPU, self.Jx_GPU, self.Jy_GPU, self.Jz_GPU, \\ self.total_grid_s) time_index_in_GPU（）——The time index calculation is performed to prevent the iteration process from exceeding the maximum time step； def time_index_in_GPU(i_time, len_time_snapshots): return (i_time//len_time_snapshots, i_time%len_time_snapshots) copy_new_rho_J_to_GPU（）—— All current densities and charge densities are recorded according to the time index； @cuda.jit def copy_new_rho_J_to_GPU(i_time, rho, Jx, Jy, Jz, \\ rho_GPU, Jx_GPU, Jy_GPU, Jz_GPU, \\ total_grid_s): i = cuda.grid(1) # loop through each spatial grid if i &lt; total_grid_s: rho_GPU[i_time, i] = rho[i] Jx_GPU[i_time, i] = Jx[i] Jy_GPU[i_time, i] = Jy[i] Jz_GPU[i_time, i] = Jz[i] signal_indicator（） The function primarily determines whether there is an overlap between the user-defined source region and the target region positions and provides indices for different scenarios. The Params: ​ o indicates observational and s indicates source ​ dx_o, dy_o, dz_o, x_left_boundary_o, y_left_boundary_o, z_left_boundary_o ​ dx_s, dy_s, dz_s, x_left_boundary_s, y_left_boundary_s, z_left_boundary_s ​ x_grid_size_o, y_grid_size_o, z_grid_size_o ​ x_grid_size_s, y_grid_size_s, z_grid_size_s def signal_indicator(dx_o, dy_o, dz_o, x_left_boundary_o, y_left_boundary_o, z_left_boundary_o, \\ dx_s, dy_s, dz_s, x_left_boundary_s, y_left_boundary_s, z_left_boundary_s, \\ x_grid_size_o, y_grid_size_o, z_grid_size_o, \\ x_grid_size_s, y_grid_size_s, z_grid_size_s): # find the left and right boundaries x_right_boundary_o, y_right_boundary_o, z_right_boundary_o = x_left_boundary_o + dx_o*x_grid_size_o, \\ y_left_boundary_o + dy_o*y_grid_size_o, \\ z_left_boundary_o + dz_o*z_grid_size_o x_right_boundary_s, y_right_boundary_s, z_right_boundary_s = x_left_boundary_s + dx_s*x_grid_size_s, \\ y_left_boundary_s + dy_o*y_grid_size_s, \\ z_left_boundary_s + dz_o*z_grid_size_s xro,yro,zro,xlo,ylo,zlo,xrs,yrs,zrs,xls,yls,zls = x_right_boundary_o, y_right_boundary_o, z_right_boundary_o,\\ x_left_boundary_o, y_left_boundary_o, z_left_boundary_o, \\ x_right_boundary_s, y_right_boundary_s, z_right_boundary_s, \\ x_left_boundary_s, y_left_boundary_s, z_left_boundary_s # there are four cases for the relavent spatial positions of the two regions # we use the boundaries points in observational region to subtract the boundaries in source region # first we compare the points in observational region with source region ob = [] for i in (xlo,xro): ii=step_func(i,xls,xrs) for j in (ylo,yro): jj=step_func(j,yls,yrs) for k in (zlo,zro): kk=step_func(k,zls,zrs) ob.append([ii,jj,kk]) # count how many 8 or -8 and where are they sob = np.sum(ob,0) count, index, sign = conut_eights_or_minus_eights(sob) # the two regions overlap if count == 0: return 0. # one direction exceeds elif count == 1: return sign_distance(sign[0], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[0]) # two directions exceed elif count == 2: r1 = sign_distance(sign[0], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[0]) r2 = sign_distance(sign[1], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[1]) return math.sqrt(r1**2+r2**2) elif count ==3: r1 = sign_distance(sign[0], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[0]) r2 = sign_distance(sign[1], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[1]) r3 = sign_distance(sign[2], xlo,ylo,zlo, xrs,yrs,zrs, xls,yls,zls, xro,yro,zro, index[2]) return math.sqrt(r1**2+r2**2+r3**2) step_func（） The “sob” divides the configuration of the observation region (x_r, x_l; y_r, y_l; z_r, z_l) into eight groups and compares them with the source region. If the left boundary of the observation region is less than the source region, it assigns -1. If it is between them, it assigns 0. If it is greater, it assigns 1. It then sums up all the results. ob = [] for i in (xlo,xro): ii=step_func(i,xls,xrs) for j in (ylo,yro): jj=step_func(j,yls,yrs) for k in (zlo,zro): kk=step_func(k,zls,zrs) ob.append([ii,jj,kk]) def step_func(x, l, r): '''compare x with l and r. return -1 or 0 or 1.''' if x&lt;l: return -1 elif x&gt;r: return 1 else: return 0 conut_eights_or_minus_eights() Perform an evaluation on the function ‘sob’. The variable “count” indicates whether there is an overlap between the source area and the observation area.: count = 1 indicates that there is no overlap in one direction； count = 2 indicates that there is no overlap in two directions； count = 3 indicates that there is no overlap between the source area and the observation area. The variable “indx” indicates which axis the source area and the observation area overlap: indx = 0 indicates that there is no overlap in the x-axis； indx = 1 indicates that there is no overlap in the y-axis； indx = 2 indicates that there is no overlap in the z-axis. The variable “sign” indicates the direction of overlap between the source area and the observation area: sign = -1 indicates that the observation area is to the left of the source area; sign = 1 indicates that the observation area is to the right of the source area. def conut_eights_or_minus_eights(x): count = 0 index = [] sign = [] for i in range(3): if abs(x[i]) == 8: count+=1 index.append(i) sign.append(x[i]/8) return count,index,sign Jefimenko_solver（） The function primarily calculates the electric field and magnetic field using the Jefimenko’s equations. At the same time, the program has incorporated the functionality of variable dt during the updating process, which means that it can automatically adjust the appropriate dt based on the simulation process during runtime. This feature provides the program with a wider range of application environments. The Params: ​ rho, Jx, Jy, Jz: physical quantities of shape [total_grid_s] ​ current_dt: the time step used in updation ​ quasi_neutral: if quasi_neutral == 1, the system only considers the contribution of electric current ​ back_to_previous: ​ whether to use the previous distribution for updation ​ time_stride_back: ​ If distribution f(i) at time i is ilegal change f(i) to f(i-time_stride_back) def Jefimenko_solver(self, rho, Jx, Jy, Jz, current_dt, quasi_neutral, back_to_previous, time_stride_back): self.dt_list.append(current_dt) if back_to_previous == 0: # i_time: int, index at which to copy the data self.i_time = self.time_tick%self.len_time_snapshots # time_index_in_GPU(self.time_tick, self.len_time_snapshots) # copy newly calculated rho and J to GPU self.rho_GPU[self.i_time], self.Jx_GPU[self.i_time], self.Jy_GPU[self.i_time], self.Jz_GPU[self.i_time] = rho, Jx, Jy, Jz self.dt_series[self.i_time] = current_dt self.t = sum(self.dt_list) else: # i_time: int, index at which to copy the data self.i_time = (self.time_tick- time_stride_back)%self.len_time_snapshots # time_index_in_GPU(self.time_tick, self.len_time_snapshots) self.time_tick = self.time_tick - time_stride_back # copy newly calculated rho and J to GPU try: self.rho_GPU[self.i_time+1 :self.i_time + time_stride_back], self.Jx_GPU[self.i_time+1 :self.i_time + time_stride_back], \\ self.Jy_GPU[self.i_time+1 :self.i_time + time_stride_back], self.Jz_GPU[self.i_time+1 :self.i_time + time_stride_back] = 0, 0, 0, 0 except: # if self.i_time + time_stride_back &gt; time_snap_shots '''Jun-Jie Zhang 2023/07/20''' self.rho_GPU[self.i_time+1 :], self.Jx_GPU[self.i_time+1 :], \\ self.Jy_GPU[self.i_time+1 :], self.Jz_GPU[self.i_time+1 :] = 0, 0, 0, 0 self.rho_GPU[:time_stride_back-(self.len_time_snapshots-(self.i_time+1))], self.Jx_GPU[:time_stride_back-(self.len_time_snapshots-(self.i_time+1))], \\ self.Jy_GPU[:time_stride_back-(self.len_time_snapshots-(self.i_time+1))], self.Jz_GPU[:time_stride_back-(self.len_time_snapshots-(self.i_time+1))] = 0, 0, 0, 0 self.dt_series[self.i_time:] = 0 self.dt_series[self.i_time] = current_dt self.dt_list[-time_stride_back:] = [0] * time_stride_back self.t = sum(self.dt_list) # save the sequences of dt from the current time step till the previous len_time_snapshots-th and the index accumu_i_time = self.i_time accumu_time_steps = current_dt for i_reorder_time in range(self.len_time_snapshots): self.accumu_dt_series[i_reorder_time] = accumu_time_steps self.accumu_dt_index[i_reorder_time] = accumu_i_time accumu_i_time -= 1 if accumu_i_time&lt;0: accumu_i_time += self.len_time_snapshots accumu_time_steps += self.dt_series[accumu_i_time] # define device array of E and B with zero initial values GEx, GEy, GEz, GBx, GBy, GBz = (cupy.zeros(self.total_grid_o, dtype=np.float64) for _ in range(6)) if quasi_neutral == 1: # calculate E and B Jefimenko_kernel[self.blockspergrid_o, self.threadsperblock](self.rho_GPU, self.Jx_GPU, self.Jy_GPU, self.Jz_GPU, \\ self.len_time_snapshots, current_dt, self.t, \\ self.accumu_dt_index, self.accumu_dt_series, \\ self.total_grid_o, self.total_grid_s, \\ self.x_grid_size_o, self.y_grid_size_o, self.z_grid_size_o, \\ self.x_grid_size_s, self.y_grid_size_s, self.z_grid_size_s, \\ self.dx_o, self.dy_o, self.dz_o, \\ self.dx_s, self.dy_s, self.dz_s, \\ self.x_left_boundary_o, self.y_left_boundary_o, self.z_left_boundary_o, \\ self.x_left_boundary_s, self.y_left_boundary_s, self.z_left_boundary_s, \\ GEx, GEy, GEz, GBx, GBy, GBz, self.coeff_E, self.coeff_B, self.c) self.GEx, self.GEy, self.GEz, self.GBx, self.GBy, self.GBz = GEx*self.coeff_E, GEy*self.coeff_E, GEz*self.coeff_E, GBx*self.coeff_B, GBy*self.coeff_B, GBz*self.coeff_B # very small values are forced to be zero self.GEx, self.GEy, self.GEz, self.GBx, self.GBy, self.GBz = \\ cupy.where(cupy.abs(self.GEx)&lt;10**(-18),0.,self.GEx),\\ cupy.where(cupy.abs(self.GEy)&lt;10**(-18),0.,self.GEy),\\ cupy.where(cupy.abs(self.GEz)&lt;10**(-18),0.,self.GEz),\\ cupy.where(cupy.abs(self.GBx)&lt;10**(-18),0.,self.GBx),\\ cupy.where(cupy.abs(self.GBy)&lt;10**(-18),0.,self.GBy),\\ cupy.where(cupy.abs(self.GBz)&lt;10**(-18),0.,self.GBz) # add one executed time step on time_tick self.time_tick += 1 # save the passed time in accumulate time_seg Jefimenko_kernel() - performs parallel computation; ​ Firstly, it associates the block index in parallel computation with the corresponding position; i_o = cuda.grid(1) # loop through each spatial grid in the observation region if i_o &lt; total_grid_o: # convert 1D grid index into 3D iz_o = i_o%z_grid_size_o iz_rest_o = i_o//z_grid_size_o iy_o = iz_rest_o%y_grid_size_o iy_rest_o = iz_rest_o//y_grid_size_o ix_o = iy_rest_o%x_grid_size_o # express the position corresponding to the index x_o, y_o, z_o = real_position(ix_o, dx_o, x_left_boundary_o), \\ real_position(iy_o, dy_o, y_left_boundary_o), \\ real_position(iz_o, dz_o, z_left_boundary_o) # loop through all spatial grid in the source region for integration for i_s in range(total_grid_s): # 1D to 3D iz_s = i_s%z_grid_size_s iz_rest_s = i_s//z_grid_size_s iy_s = iz_rest_s%y_grid_size_s iy_rest_s = iz_rest_s//y_grid_size_s ix_s = iy_rest_s%x_grid_size_s # positions x_s, y_s, z_s = real_position(ix_s, dx_s, x_left_boundary_s), \\ real_position(iy_s, dy_s, y_left_boundary_s), \\ real_position(iz_s, dz_s, z_left_boundary_s) # dr = r - r' = r_o - r_s dx = x_o - x_s dy = y_o - y_s dz = z_o - z_s dr = r_distance(x_o, y_o, z_o, x_s, y_s, z_s) Next, it calculates the time delay to prevent the time iteration process from exceeding the maximum time step; if dr &gt; 10**-10: # find the retarded time for positions r_o # rtime_i gives the index of time in time_snapshots, it can be negtive rtime_i = retarded_time_index(t, dr, dt, i_round, len_time_snapshots) # rtime_i_minus: index for retarded_time - dt if rtime_i &lt; 0: # no updation since signal has not arrived yet pass else: if rtime_i == 0: rtime_i_minus = len_time_snapshots-1 elif rtime_i &gt; 0: rtime_i_minus = rtime_i - 1 @cuda.jit(device=True) def retarded_time_index(t, dr, dt, i_round, len_time_snapshots): tr = t - dr # if the signal has not been transmitted if tr &lt; 0.: return -1 # the current time tr corresponds to the ti-th row ti = int(math.floor(tr/dt)%len_time_snapshots) # if ti corresponds to the last row if ti == len_time_snapshots - 1: return 0 else: return ti + 1 Calculate the time derivatives of current density and charge density： rho_s, rho_minus_s = rho_GPU_s[rtime_i, i_s], rho_GPU_s[rtime_i_minus, i_s] Jx_s, Jx_minus_s = Jx_GPU_s[rtime_i, i_s], Jx_GPU_s[rtime_i_minus, i_s] Jy_s, Jy_minus_s = Jy_GPU_s[rtime_i, i_s], Jy_GPU_s[rtime_i_minus, i_s] Jz_s, Jz_minus_s = Jz_GPU_s[rtime_i, i_s], Jz_GPU_s[rtime_i_minus, i_s] prho_pt_s = (rho_s - rho_minus_s)/dt pJx_pt_s = (Jx_s - Jx_minus_s)/dt pJy_pt_s = (Jy_s - Jy_minus_s)/dt pJz_pt_s = (Jz_s - Jz_minus_s)/dt The current and charge densities are divided into three dimensions and summed using CUDA atomic operations； cuda.atomic.add(GEx, i_o, (x_o-x_s)/dr**3*rho_s+(x_o-x_s)/dr**2*prho_pt_s-1/dr*pJx_pt_s) cuda.atomic.add(GEy, i_o, (y_o-y_s)/dr**3*rho_s+(y_o-y_s)/dr**2*prho_pt_s-1/dr*pJy_pt_s) cuda.atomic.add(GEz, i_o, (z_o-z_s)/dr**3*rho_s+(z_o-z_s)/dr**2*prho_pt_s-1/dr*pJz_pt_s) cuda.atomic.add(GBx, i_o, -(((y_o-y_s)*Jz_s-(z_o-z_s)*Jy_s)/dr**3+((y_o-y_s)*pJz_pt_s-(z_o-z_s)*pJy_pt_s)/dr**2)) cuda.atomic.add(GBy, i_o, -(((z_o-z_s)*Jx_s-(x_o-x_s)*Jz_s)/dr**3+((z_o-z_s)*pJx_pt_s-(x_o-x_s)*pJz_pt_s)/dr**2)) cuda.atomic.add(GBz, i_o, -(((x_o-x_s)*Jy_s-(y_o-y_s)*Jx_s)/dr**3+((x_o-x_s)*pJy_pt_s-(y_o-y_s)*pJx_pt_s)/dr**2))"
  },"/jekyll/2022-07-08-Vlasov-Drifit-terms.html": {
    "title": "Vlasov_Drifit_terms",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-08-Vlasov-Drifit-terms.html",
    "body": "The program primarily leverages the difference to compute the Drift term. Advantages of the program： Fast parallel processing of Drifit terms with CUDA Utilizing UPFD methods and flux limiters to ensure “constant positive” computational processes The main function of the program: Drift_Vlasov_terms() This function mainly calculates the Drifit term： The initialization process is executed initially, while the Drift term is concurrently calculated using the kernel function. def Drift_Vlasov_terms(f_x_p_t, Fx, Fy, Fz, \\ masses, total_grid, num_of_particle_types, \\ npx, npy, npz, nx, ny, nz, \\ half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, number_momentum_levels,\\ x_bound_config, y_bound_config, z_bound_config, \\ blockspergrid_total_phase, threadsperblock,\\ collision_term, dt, c, current_time_step, \\ whether_drift, whether_Vlasov, drift_order): f_updated = cupy.zeros_like(f_x_p_t) drift_force_term_kernel[blockspergrid_total_phase, threadsperblock]\\ (f_x_p_t, Fx, Fy, Fz, \\ masses, total_grid, num_of_particle_types, \\ npx, npy, npz, nx, ny, nz,\\ half_px, half_py, half_pz, \\ dx, dy, dz, dpx, dpy, dpz, number_momentum_levels,\\ x_bound_config, y_bound_config, z_bound_config, \\ f_updated, collision_term, \\ dt, c, current_time_step, whether_drift, whether_Vlasov,\\ drift_order) return f_updated Furthermore, there is a correspondence established between GPU threads and momentum, spatial grids: This primarily involves the mutual conversion between three-dimensional position space and three-dimensional momentum space with one-dimensional thread indices. Special processing is applied to indices located at boundary conditions. i_grid = cuda.grid(1) if i_grid &lt; total_grid: # convert one-d index into six-d ipz = i_grid%npz ipz_rest = i_grid//npz ipy = ipz_rest%npy ipy_rest = ipz_rest//npy ipx = ipy_rest%npx ipx_rest = ipy_rest//npx iz = ipx_rest%nz iz_rest = ipx_rest//nz iy = iz_rest%ny iy_rest = iz_rest//ny ix = iy_rest%nx # distribution functions out of the computation domain of each card are always set to be 0 ixPlus = (ix+1) iyPlus = (iy+1) izPlus = (iz+1) ixMinus = (ix-1) iyMinus = (iy-1) izMinus = (iz-1) ixPlusPlus = (ix+2) iyPlusPlus = (iy+2) izPlusPlus = (iz+2) ixMinusMinus = (ix-2) iyMinusMinus = (iy-2) izMinusMinus = (iz-2) # convert six-d to one-d i_phasexmin = threeD_to_oneD(ixMinus, iy, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasexmax = threeD_to_oneD(ixPlus, iy, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phaseymin = threeD_to_oneD(ix, iyMinus, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phaseymax = threeD_to_oneD(ix, iyPlus, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasezmin = threeD_to_oneD(ix, iy, izMinus, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasezmax = threeD_to_oneD(ix, iy, izPlus, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasexminmin = threeD_to_oneD(ixMinusMinus, iy, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasexmaxmax = threeD_to_oneD(ixPlusPlus, iy, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phaseyminmin = threeD_to_oneD(ix, iyMinusMinus, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phaseymaxmax = threeD_to_oneD(ix, iyPlusPlus, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasezminmin = threeD_to_oneD(ix, iy, izMinusMinus, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasezmaxmax = threeD_to_oneD(ix, iy, izPlusPlus, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz) # enforce periodical boundary conditions, ipxPlus --&gt; ipx+1 ipxPlus = (ipx+1)%npx ipyPlus = (ipy+1)%npy ipzPlus = (ipz+1)%npz # -1%3 should be 2, but cuda yields 0, so we use ipxMinus = (ipx-1+npx)%npx ipyMinus = (ipy-1+npy)%npy ipzMinus = (ipz-1+npz)%npz # convert six-d to one-d i_phasepxmin = threeD_to_oneD(ix, iy, iz, ipxMinus, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasepxmax = threeD_to_oneD(ix, iy, iz, ipxPlus, ipy, ipz, nx, ny, nz, npx, npy, npz) i_phasepymin = threeD_to_oneD(ix, iy, iz, ipx, ipyMinus, ipz, nx, ny, nz, npx, npy, npz) i_phasepymax = threeD_to_oneD(ix, iy, iz, ipx, ipyPlus, ipz, nx, ny, nz, npx, npy, npz) i_phasepzmin = threeD_to_oneD(ix, iy, iz, ipx, ipy, ipzMinus, nx, ny, nz, npx, npy, npz) i_phasepzmax = threeD_to_oneD(ix, iy, iz, ipx, ipy, ipzPlus, nx, ny, nz, npx, npy, npz) The equation is decomposed into three parts : ​ The calculation is performed on the first part and its momentum： for p_type in range(num_of_particle_types): # masses mp_squared = masses[p_type]**2 # loop through all momentum levels for i_level in range(number_momentum_levels): fcurrent = f_x_p_t[i_level, p_type, i_grid] # parts of the numerator in UPFD numerator0 = fcurrent/dt/3. # vx, vy, vz vx = 0. vy = 0. vz = 0. # Fx, Fy, Fz Fcurrentpx = 0. Fcurrentpy = 0. Fcurrentpz = 0. # acquire p from the central value # Note that for different particles, they have different dpx and px_left_bound # the momentum level corresponds to the level of straitification px = ((ipx+0.5)*dpx[p_type] - half_px[p_type])/(npx**i_level) py = ((ipy+0.5)*dpy[p_type] - half_py[p_type])/(npy**i_level) pz = ((ipz+0.5)*dpz[p_type] - half_pz[p_type])/(npz**i_level) # p0 for current grid p0 = math.sqrt(mp_squared*c**2+px**2+py**2+pz**2) # p0 = math.sqrt((mp_squared*c)**2+px**2+py**2+pz**2) if p0 &gt; 10**(-13): vx = c*px/p0 vy = c*py/p0 vz = c*pz/p0 The values of the distribution function at the left and right boundaries are constrained： fleftx = left_bound_detect(ixMinus, f_x_p_t, i_level, p_type, i_phasexmin) flefty = left_bound_detect(iyMinus, f_x_p_t, i_level, p_type, i_phaseymin) fleftz = left_bound_detect(izMinus, f_x_p_t, i_level, p_type, i_phasezmin) frightx = right_bound_detect(ixPlus, nx, f_x_p_t, i_level, p_type, i_phasexmax) frighty = right_bound_detect(iyPlus, ny, f_x_p_t, i_level, p_type, i_phaseymax) frightz = right_bound_detect(izPlus, nz, f_x_p_t, i_level, p_type, i_phasezmax) fleftleftx = left_bound_detect(ixMinusMinus, f_x_p_t, i_level, p_type, i_phasexminmin) fleftlefty = left_bound_detect(iyMinusMinus, f_x_p_t, i_level, p_type, i_phaseyminmin) fleftleftz = left_bound_detect(izMinusMinus, f_x_p_t, i_level, p_type, i_phasezminmin) frightrightx = right_bound_detect(ixPlusPlus, nx, f_x_p_t, i_level, p_type, i_phasexmaxmax) frightrighty = right_bound_detect(iyPlusPlus, ny, f_x_p_t, i_level, p_type, i_phaseymaxmax) frightrightz = right_bound_detect(izPlusPlus, nz, f_x_p_t, i_level, p_type, i_phasezmaxmax) The invoked functions are shown below： @cuda.jit(device=True) def left_bound_detect(ixMinus, f_x_p_t, i_level, p_type, i_phasexmin): # if ixMinus is smaller than 0, set f -&gt; 0 if ixMinus &lt; -0.5: return 0. else: return f_x_p_t[i_level, p_type, i_phasexmin] @cuda.jit(device=True) def right_bound_detect(ixPlus, nx, f_x_p_t, i_level, p_type, i_phasexmax): # if ixPlus is larger than nx-1, set f -&gt; 0 if ixPlus &gt; (nx-0.5): return 0. else: return f_x_p_t[i_level, p_type, i_phasexmax] The computation of the “Drift term” and “Vlasov term” is provided in two different ways: First-order and Second-order.： whether_drift—-Parameter for the computation of the Drift term (&gt;0.5 indicates computation)； whether_Vlasov—-Parameter for the computation of the Vlasov term (&gt;0.5 indicates computation); drift_order—-Parameter for selecting the order (&gt;1.5 indicates second-order format; &lt;1.5 indicates first-order format) Default value in the program is 2, which can be modified by the user. The Drifit term is initially computed using the first-order approach. The expression in the program is: if whether_drift &gt; 0.5: if drift_order &lt; 1.5: # first order upwind numerator1 = UPFD(dx, vx, fleftx, frightx) + UPFD(dy, vy, flefty, frighty) + UPFD(dz, vz, fleftz, frightz) # denominator # 1/dt+vx/dx+vy/dy+vz/dz+Fx/dpx+Fy/dpy+Fz/dpz denominator1 = 1/dt+3*abs(vx/dx)+3*abs(vy/dy)+3*abs(vz/dz) f_drift = (numerator0+numerator1)/denominator1 The functions used are shown below: @cuda.jit(device=True) def UPFD(dx, vx, fleft, fright): # method from doi:10.1016/j.mcm.2011.05.005 if vx &gt; 0.: if abs(vx)&lt;10**(-19): vx = 0. return vx/dx*fleft else: if abs(vx)&lt;10**(-19): vx = 0. return -vx/dx*fright Calculation of the drifit term in a second-order manner elif drift_order &gt; 1.5: theta = 10**(-10) ############################################### # flux_x F_plus_i_x = F_plus_minus(1, vx, fcurrent) F_plus_i_plus_1_x = F_plus_minus(1, vx, frightx) F_plus_i_minus_1_x = F_plus_minus(1, vx, fleftx) F_plus_i_minus_2_x = F_plus_minus(1, vx, fleftleftx) F_minus_i_x = F_plus_minus(-1, vx, fcurrent) F_minus_i_minus_1_x = F_plus_minus(-1, vx, fleftx) F_minus_i_plus_1_x = F_plus_minus(-1, vx, frightx) F_minus_i_plus_2_x = F_plus_minus(-1, vx, frightrightx) ################################################# # flux_y F_plus_i_y = F_plus_minus(1, vy, fcurrent) F_plus_i_plus_1_y = F_plus_minus(1, vy, frighty) F_plus_i_minus_1_y = F_plus_minus(1, vy, flefty) F_plus_i_minus_2_y = F_plus_minus(1, vy, fleftlefty) F_minus_i_y = F_plus_minus(-1, vy, fcurrent) F_minus_i_minus_1_y = F_plus_minus(-1, vy, flefty) F_minus_i_plus_1_y = F_plus_minus(-1, vy, frighty) F_minus_i_plus_2_y = F_plus_minus(-1, vy, frightrighty) #################################################### # flux_z F_plus_i_z = F_plus_minus(1, vz, fcurrent) F_plus_i_plus_1_z = F_plus_minus(1, vz, frightz) F_plus_i_minus_1_z = F_plus_minus(1, vz, fleftz) F_plus_i_minus_2_z = F_plus_minus(1, vz, fleftleftz) F_minus_i_z = F_plus_minus(-1, vz, fcurrent) F_minus_i_minus_1_z = F_plus_minus(-1, vz, fleftz) F_minus_i_plus_1_z = F_plus_minus(-1, vz, frightz) F_minus_i_plus_2_z = F_plus_minus(-1, vz, frightrightz) The functions used are shown below: @cuda.jit(device=True) def F_plus_minus(sign, vx, fcurrent): if vx*sign &gt; 0.: return vx*fcurrent else: return 0. Flux Limiter: # flux limiter_x phi_plus_i_plus_half_x = phi_plus(F_plus_i_minus_1_x, F_plus_i_x, F_plus_i_plus_1_x, theta) phi_minus_i_plus_half_x = phi_minus(F_minus_i_x, F_minus_i_plus_1_x, F_minus_i_plus_2_x, theta) phi_plus_i_minus_half_x = phi_plus(F_plus_i_minus_2_x, F_plus_i_minus_1_x, F_plus_i_x, theta) phi_minus_i_minus_half_x = phi_minus(F_minus_i_minus_1_x, F_minus_i_x, F_minus_i_plus_1_x, theta) # flux limiter_y phi_plus_i_plus_half_y = phi_plus(F_plus_i_minus_1_y, F_plus_i_y, F_plus_i_plus_1_y, theta) phi_minus_i_plus_half_y = phi_minus(F_minus_i_y, F_minus_i_plus_1_y, F_minus_i_plus_2_y, theta) phi_plus_i_minus_half_y = phi_plus(F_plus_i_minus_2_y, F_plus_i_minus_1_y, F_plus_i_y, theta) phi_minus_i_minus_half_y = phi_minus(F_minus_i_minus_1_y, F_minus_i_y, F_minus_i_plus_1_y, theta) # flux limiter_z phi_plus_i_plus_half_z = phi_plus(F_plus_i_minus_1_z, F_plus_i_z, F_plus_i_plus_1_z, theta) phi_minus_i_plus_half_z = phi_minus(F_minus_i_z, F_minus_i_plus_1_z, F_minus_i_plus_2_z, theta) phi_plus_i_minus_half_z = phi_plus(F_plus_i_minus_2_z, F_plus_i_minus_1_z, F_plus_i_z, theta) phi_minus_i_minus_half_z = phi_minus(F_minus_i_minus_1_z, F_minus_i_z, F_minus_i_plus_1_z, theta) The functions used are shown below: # define limiter function phi_minus @cuda.jit(device=True) def phi_minus(F_minus, F_minus_right, F_minus_rightright, theta): if abs(F_minus_right-F_minus_rightright) &lt; 10**(-18): monotonicity_preservation = 0. else: monotonicity_preservation = (F_minus-F_minus_right)/(F_minus_right-F_minus_rightright) if abs(F_minus_right) &lt; 10**(-18): posivity_preservation = 2/max(theta, 0.) else: posivity_preservation = 2/max(theta, (F_minus_rightright-F_minus_right)/F_minus_right) return max(0., min(1., monotonicity_preservation, posivity_preservation)) # define limiter function phi_plus @cuda.jit(device=True) def phi_plus(F_plus_left, F_plus, F_plus_right, theta): if abs(F_plus-F_plus_left) &lt; 10**(-18): monotonicity_preservation = 0. else: monotonicity_preservation = (F_plus_right-F_plus)/(F_plus-F_plus_left) if abs(F_plus) &lt; 10**(-18): posivity_preservation = 2/max(theta, 0.) else: posivity_preservation = 2/max(theta, (F_plus_left-F_plus)/F_plus) return max(0., min(1., monotonicity_preservation, posivity_preservation)) The final step in calculating the Drifit term in the second-order format integrates the results of the calculation # flux at the middle grid_x F_i_plus_half_x = F_i_plus_half(vx, F_plus_i_x, phi_plus_i_plus_half_x, F_plus_i_minus_1_x, F_minus_i_plus_1_x, phi_minus_i_plus_half_x, F_minus_i_plus_2_x) F_i_minus_half_x = F_i_plus_half(vx, F_plus_i_minus_1_x, phi_plus_i_minus_half_x, F_plus_i_minus_2_x, F_minus_i_x, phi_minus_i_minus_half_x, F_minus_i_plus_1_x) # flux at the middle grid_y F_i_plus_half_y = F_i_plus_half(vy, F_plus_i_y, phi_plus_i_plus_half_y, F_plus_i_minus_1_y, F_minus_i_plus_1_y, phi_minus_i_plus_half_y, F_minus_i_plus_2_y) F_i_minus_half_y = F_i_plus_half(vy, F_plus_i_minus_1_y, phi_plus_i_minus_half_y, F_plus_i_minus_2_y, F_minus_i_y, phi_minus_i_minus_half_y, F_minus_i_plus_1_y) # flux at the middle grid_z F_i_plus_half_z = F_i_plus_half(vz, F_plus_i_z, phi_plus_i_plus_half_z, F_plus_i_minus_1_z, F_minus_i_plus_1_z, phi_minus_i_plus_half_z, F_minus_i_plus_2_z) F_i_minus_half_z = F_i_plus_half(vz, F_plus_i_minus_1_z, phi_plus_i_minus_half_z, F_plus_i_minus_2_z, F_minus_i_z, phi_minus_i_minus_half_z, F_minus_i_plus_1_z) f_drift = fcurrent/3 - (dt/dx*(F_i_plus_half_x-F_i_minus_half_x) + dt/dy*(F_i_plus_half_y-F_i_minus_half_y) + dt/dz*(F_i_plus_half_z-F_i_minus_half_z)) The functions used are shown below: # define flux F_i_plus_half @cuda.jit(device=True) def F_i_plus_half(vx, F_plus_i, phi_plus_i_plus_half, F_plus_i_minus_1, F_minus_i_plus_1, phi_minus_i_plus_half, F_minus_i_plus_2): return F_plus_i + 0.5*phi_plus_i_plus_half*(F_plus_i-F_plus_i_minus_1) + F_minus_i_plus_1 + 0.5*phi_minus_i_plus_half*(F_minus_i_plus_1-F_minus_i_plus_2) The Vlasov term is calculated using the same approach. if whether_Vlasov &gt; 0.5: if drift_order &lt; 1.5: # first order upwind # Vlasov term fleftpx = f_x_p_t[i_level, p_type, i_phasepxmin] fleftpy = f_x_p_t[i_level, p_type, i_phasepymin] fleftpz = f_x_p_t[i_level, p_type, i_phasepzmin] frightpx = f_x_p_t[i_level, p_type, i_phasepxmax] frightpy = f_x_p_t[i_level, p_type, i_phasepymax] frightpz = f_x_p_t[i_level, p_type, i_phasepzmax] # External forces at p, p-dpx, px+dpx Fcurrentpx = Fx[i_level, p_type, i_grid] Fcurrentpy = Fy[i_level, p_type, i_grid] Fcurrentpz = Fz[i_level, p_type, i_grid] numerator2 = UPFD(dpx[p_type], Fcurrentpx, fleftpx, frightpx) + UPFD(dpy[p_type], Fcurrentpy, fleftpy, frightpy) + UPFD(dpz[p_type], Fcurrentpz, fleftpz, frightpz) # denominator # 1/dt+vx/dx+vy/dy+vz/dz+Fx/dpx+Fy/dpy+Fz/dpz denominator2 = 1/dt+3*abs(Fcurrentpx/dpx[p_type])+3*abs(Fcurrentpy/dpy[p_type])+3*abs(Fcurrentpz/dpz[p_type]) f_driftp = (numerator0+numerator2)/denominator2 The collision term is incorporated into the distribution function. cuda.atomic.add(f_updated, (i_level, p_type, i_grid), fcurrent/3 + dt*collision_term[i_level, p_type, i_grid]) Adjustments are made to the values at the problematic boundaries. The same method is applied to handle the x, y, and z directions separately. denominator = 1/dt+3*abs(vx/dx)+3*abs(vy/dy)+3*abs(vz/dz) # corrections due to the physical boundary, we consider reflection and absorption or in between if vx &gt; 0: # if vx &gt; 0, the right most boundary needs to be considered if ix &gt; (nx - 1.5): # mirror index for ipx ipx_mirror = mirror(npx, ipx) i_grid_mirror = threeD_to_oneD(ix, iy, iz, ipx_mirror, ipy, ipz, nx, ny, nz, npx, npy, npz) cuda.atomic.add(f_updated, (i_level, p_type, i_grid_mirror), UPFD(dx, vx, fcurrent, 0)/(denominator)*(1-x_bound_config[iy, iz])) else: # if vx &lt; 0., the left most boundary needs to be considered if ix &lt; 0.5: # mirror in dex for ipx ipx_mirror = mirror(npx, ipx) i_grid_mirror = threeD_to_oneD(ix, iy, iz, ipx_mirror, ipy, ipz, nx, ny, nz, npx, npy, npz) cuda.atomic.add(f_updated, (i_level, p_type, i_grid_mirror), UPFD(dx, vx, 0, fcurrent)/(denominator)*(1-x_bound_config[iy, iz])) The functions used are shown below: @cuda.jit(device=True) def mirror(ngrid, i): return ngrid-i-1 @cuda.jit(device=True) def threeD_to_oneD(ix, iy, iz, ipx, ipy, ipz, nx, ny, nz, npx, npy, npz): return ipz+ipy*npz+ipx*npz*npy+iz*npz*npy*npx+iy*npz*npy*npx*nz+ix*npz*npy*npx*nz*ny"
  },"/jekyll/2022-07-07-Collision.html": {
    "title": "Collision",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-07-Collision.html",
    "body": "This program addresses the computation of 2-2, 2-3, and 3-2 collision terms in different systems: where the 2-2 collision term is： 2-3 collision term is： 3-2 collision term is： To understand the background and principles of the application of the program you can refer to the following article Towards a full solution of the relativistic Boltzmann equation for quark-gluon matter on GPUs Advantages of the program Solving high-dimensional integrals by Monte Carlo methods; Conservation of particle number by “symmetric sampling” method; Reducing computation time with CUDA_Atomic calculations; Parallelizing programs with CUDA. Structure of the program Since the program structures in the three collision processes are basically the same, only the 2-2 collision process is described in detail, while the differences in the 2-3, 3-2 collision program are labeled. Init collision_type_for_all_species（） Main Collision_term（） collision_term_kernel（） collision_term_at_specific_point（） accumulate_collision_term（） other_calculation Amplitude_square（） H_fun（） C1_fun（） C2_fun（） threeD_to_oneD（） The running logic of the whole program is shown below: collision_term_kernel（） This function performs the parallelization of the program and contains two main functions: 1、Corresponding the block indexes of the parallel computation to the momentum space and the position space; 2、Computing the momentum and energy of the particles. The program corresponds the vector, positional indexes to the ‘thread’, and the 6 dimensions become 1 dimension; i_grid = cuda.grid(1) if i_grid &lt; total_grid: # convert one-d index into six-d ipz = i_grid%npz ipz_rest = i_grid//npz ipy = ipz_rest%npy ipy_rest = ipz_rest//npy ipx = ipy_rest%npx ipx_rest = ipy_rest//npx iz = ipx_rest%nz iz_rest = ipx_rest//nz iy = iz_rest%ny iy_rest = iz_rest//ny ix = iy_rest%nx Calculate the momentum and energy of different particles: for p_type in range(num_of_particle_types): px = ((ipx+0.5)*dpx[p_type] - half_px[p_type])/(npx**i_level) py = ((ipy+0.5)*dpy[p_type] - half_py[p_type])/(npy**i_level) pz = ((ipz+0.5)*dpz[p_type] - half_pz[p_type])/(npz**i_level) mp_squared = masses[p_type]**2 p0 = math.sqrt(mp_squared*c**2+px**2+py**2+pz**2) collision_term_at_specific_point（） This function consists of two main functions: 1、Calculate int_vloume; 2、Calculate k1z1, k1z2 using Monte Carlo method; Calculate int_volume: 2-2 Collision： if collision_type[i_collision] &lt; 1000: flavor0 = flavor[i_collision,0] flavor1 = flavor[i_collision,1] flavor2 = flavor[i_collision,2] int_volume = 2**5*half_px[flavor0]*half_py[flavor0]*half_px[flavor2]*half_py[flavor2]\\ *half_pz[flavor2]/(num_samples*4) m1 = masses[flavor0] m2 = masses[flavor1] m3 = masses[flavor2] 2-3 Collision： if collision_type[i_collision] &lt; 1000: int_volume = 2**8*half_px[flavor[i_collision,0]]*half_py[flavor[i_collision,0]]\\ *half_px[flavor[i_collision,2]]*half_py[flavor[i_collision,2]]*half_pz[flavor[i_collision,2]]\\ *half_px[flavor[i_collision,3]]*half_py[flavor[i_collision,3]]*half_pz[flavor[i_collision,3]]\\ /(num_samples*5) 3-2 Collision： if collision_type[i_collision] &lt; 1000: int_volume = 2**8*half_px[flavor[i_collision,3]]*half_py[flavor[i_collision,3]]\\ *half_px[flavor[i_collision,2]]*half_py[flavor[i_collision,2]]*half_pz[flavor[i_collision,2]]\\ *half_px[flavor[i_collision,0]]*half_py[flavor[i_collision,0]]*half_pz[flavor[i_collision,0]]\\ /(num_samples*5) Calculation of k1z1, k1z2 using Monte Carlo for the purpose of calculating Ja： 2-2 Collision: for i_sample in range(num_samples): k1x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor0] k1y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor0] k3x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor2] k3y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor2] k3z = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_pz[flavor2] k30 = math.sqrt(m3**2*c**2+k3x**2+k3y**2+k3z**2) C1 = C1_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,p0,px,py,pz,c) C2 = C2_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,p0,px,py,pz,c) H = H_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,p0,px,py,pz,c) if H&gt;1e-13 and abs(C2)&gt;1e-13: k1z1, k1z2 = (C1+math.sqrt(H))/C2, (C1-math.sqrt(H))/C2 **2-3 Collision: ** for i_sample in range(num_samples): # masses of the particles m1 = masses[flavor[i_collision,0]] m2 = masses[flavor[i_collision,1]] m3 = masses[flavor[i_collision,2]] m4 = masses[flavor[i_collision,3]] mp = masses[flavor[i_collision,4]] # randomly generate k1x, k1y, k3x, k3y, k3z # the momentum values need to be sampled according to the specific particle types k1x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,0]] k1y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,0]] k3x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,2]] k3y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,2]] k3z = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_pz[flavor[i_collision,2]] k4x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,3]] k4y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,3]] k4z = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_pz[flavor[i_collision,3]] k30 = math.sqrt(m3**2*c**2+k3x**2+k3y**2+k3z**2) k40 = math.sqrt(m4**2*c**2+k4x**2+k4y**2+k4z**2) # solving for k1z via energy conservation # k1z has two values C1 = C1_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,m4,k40,k4x,k4y,k4z,p0,px,py,pz,c) C2 = C2_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,m4,k40,k4x,k4y,k4z,p0,px,py,pz,c) H = H_fun(m1,k1x,k1y,m2,k30,k3x,k3y,k3z,m4,k40,k4x,k4y,k4z,p0,px,py,pz,c) # take the value if H&gt;1e-13 and abs(C2)&gt;1e-13 if H&gt;1e-13 and abs(C2)&gt;1e-13: k1z1, k1z2 = (C1+math.sqrt(H))/C2, (C1-math.sqrt(H))/C2 **3-2 Collision: ** for i_sample in range(num_samples): # masses of the particles m1 = masses[flavor[i_collision,0]] m2 = masses[flavor[i_collision,1]] m3 = masses[flavor[i_collision,2]] m4 = masses[flavor[i_collision,3]] mp = masses[flavor[i_collision,4]] # randomly generate k4x, k4y, k3x, k3y, k3z and k1x, k1y, k1z # the momentum values need to be sampled according to the specific particle types k1x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,0]] k1y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,0]] k1z = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_pz[flavor[i_collision,0]] k3x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,2]] k3y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,2]] k3z = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_pz[flavor[i_collision,2]] k4x = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_px[flavor[i_collision,3]] k4y = (xoroshiro128p_uniform_float64(rng_states, i_grid)*2-1)*half_py[flavor[i_collision,3]] k30 = math.sqrt(m3**2*c**2+k3x**2+k3y**2+k3z**2) k10 = math.sqrt(m1**2*c**2+k1x**2+k1y**2+k1z**2) # solving for k1z via energy conservation # k1z has two values C1 = C1_fun(k10,k1x,k1y,k1z,m2,k30,k3x,k3y,k3z,m4,k4x,k4y,p0,px,py,pz,c) C2 = C2_fun(k10,k1x,k1y,k1z,m2,k30,k3x,k3y,k3z,m4,k4x,k4y,p0,px,py,pz,c) H = H_fun(k10,k1x,k1y,k1z,m2,k30,k3x,k3y,k3z,m4,k4x,k4y,p0,px,py,pz,c) # take the value if H&gt;1e-13 and abs(C2)&gt;1e-13 if H&gt;1e-13 and abs(C2)&gt;1e-13: k4z1, k4z2 = (C1+math.sqrt(H))/C2, (C1-math.sqrt(H))/C2 accumulate_collision_term（） This function mainly solves for the final parameters and contains four functions： 1、Calculation Ja、momentum_product； 2、Calculation f0、f1、f2、fp； 3、Calculation amplitude_square； 4、Calculation collision term. Calculation Ja and momentum_product ​ Here, we choose to express k2 as k3+p-k1, which leads to a more stable integration. All computed values of k2 undergo a validation process to ensure they fall within the phase space defined by the particle. The specific calculation formula is depicted in the diagram below: ​ **2-2 Collision: ** ​ Ja ​ momentum_product ​ if k1z &gt; -half_pz[flavor0] and k1z &lt; half_pz[flavor0]: # obtain k2x, k2y, k2z via momentum conservation k2x = k3x + px - k1x k2y = k3y + py - k1y k2z = k3z + pz - k1z # k2x, k2y, k2z must also be in the momentum box range of particle 1 if (k2x &gt; -half_px[flavor1] and k2x &lt; half_px[flavor1] and k2y &gt; -half_py[flavor1] and k2y &lt; half_py[flavor1] and k2z &gt; -half_pz[flavor1] and k2z &lt; half_pz[flavor1]): # energy for particle 1 and 2 k10, k20 = math.sqrt(m1_squared*c**2+k1x**2+k1y**2+k1z**2), math.sqrt(m2_squared*c**2+k2x**2+k2y**2+k2z**2) # energy must be conserved if abs(k10+k20-k30-p0) &lt; 10**(-18): # jacobin term Ja = abs(k1z/k10 - (-k1z+k3z+pz)/k20) # momentum product momentum_product = k10*k20*k30*p0 ​ **2-3 Collision: ** ​ Ja ​ momentum_product ​ if k1z &gt; -half_pz[flavor[i_collision,0]] and k1z &lt; half_pz[flavor[i_collision,0]]: # obtain k2x, k2y, k2z via momentum conservation k2x = k3x + k4x + px - k1x k2y = k3y + k4y + py - k1y k2z = k3z + k4z + pz - k1z # k2x, k2y, k2z must also be in the momentum box range of particle 1 if (k2x &gt; -half_px[flavor[i_collision,1]] and k2x &lt; half_px[flavor[i_collision,1]] and k2y &gt; -half_py[flavor[i_collision,1]] and k2y &lt; half_py[flavor[i_collision,1]] and k2z &gt; -half_pz[flavor[i_collision,1]] and k2z &lt; half_pz[flavor[i_collision,1]]): # energy for particle 1 and 2 k10, k20 = math.sqrt(m1_squared*c**2+k1x**2+k1y**2+k1z**2), math.sqrt(m2_squared*c**2+k2x**2+k2y**2+k2z**2) # energy must be conserved if abs(k10+k20-k30-k40-p0) &lt; 10**(-18): # jacobin term Ja = abs(k1z/k10 - (-k1z+k3z+k4z+pz)/k20) # momentum product momentum_product = k10*k20*k30*k40*p0 ​ **3-2 Collision: ** ​ Ja ​ momentum_product ​ if k4z &gt; -half_pz[flavor[i_collision,3]] and k4z &lt; half_pz[flavor[i_collision,3]]: # obtain k2x, k2y, k2z via momentum conservation k2x = k4x + px - k1x - k3x k2y = k4y + py - k1y - k3y k2z = k4z + pz - k1z - k3z # k2x, k2y, k2z must also be in the momentum box range of particle 1 if (k2x &gt; -half_px[flavor[i_collision,1]] and k2x &lt; half_px[flavor[i_collision,1]] and k2y &gt; -half_py[flavor[i_collision,1]] and k2y &lt; half_py[flavor[i_collision,1]] and k2z &gt; -half_pz[flavor[i_collision,1]] and k2z &lt; half_pz[flavor[i_collision,1]]): # energy for particle 4 and 2 k40, k20 = math.sqrt(m4_squared*c**2+k4x**2+k4y**2+k4z**2), math.sqrt(m2_squared*c**2+k2x**2+k2y**2+k2z**2) # energy must be conserved if abs(k10+k20+k30-k40-p0) &lt; 10**(-18): # jacobin term Ja = abs(-k4z/k40 + (-k1z-k3z+k4z+pz)/k20) # momentum product momentum_product = k10*k20*k30*k40*p0 Calculate f and F ​ The first step is to find the “location” of the particle according to the index. if Ja&gt;1e-5 and momentum_product &gt; 10**(-19): # for particle 0 ik1x, ik1y, ik1z = int((k1x + half_px[flavor0])//dpx[flavor0]), \\ int((k1y + half_py[flavor0])//dpy[flavor0]), \\ int((k1z + half_pz[flavor0])//dpz[flavor0]) # convert grid index in one dimension i_phase_grid0 = threeD_to_oneD(ix,iy,iz,ik1x,ik1y,ik1z, \\ nx, ny, nz, npx, npy, npz) # for particle 1 ik2x, ik2y, ik2z = int((k2x + half_px[flavor1])//dpx[flavor1]), \\ int((k2y + half_py[flavor1])//dpy[flavor1]), \\ int((k2z + half_pz[flavor1])//dpz[flavor1]) # convert grid index in one dimension i_phase_grid1 = threeD_to_oneD(ix,iy,iz,ik2x,ik2y,ik2z, \\ nx, ny, nz, npx, npy, npz) # for particle 2 ik3x, ik3y, ik3z = int((k3x + half_px[flavor2])//dpx[flavor2]), \\ int((k3y + half_py[flavor2])//dpy[flavor2]), \\ int((k3z + half_pz[flavor2])//dpz[flavor2]) # convert grid index in one dimension i_phase_grid2 = threeD_to_oneD(ix,iy,iz,ik3x,ik3y,ik3z, \\ nx, ny, nz, npx, npy, npz) ​ Secondly, according to the index to find the corresponding particles of f and F and the difference ​ **2-2 Collision: ** f = cuda.local.array(shape=4, dtype=float64) f[0] = f_x_p_t0level[flavor0, i_phase_grid0] f[1] = f_x_p_t0level[flavor1, i_phase_grid1] f[2] = f_x_p_t0level[flavor2, i_phase_grid2] f[3] = f_x_p_tilevel[p_type, i_grid] # feed values of distribution function and its quantum correction tf = cuda.local.array(shape=4, dtype=float64) # particle_type: 0, 1, 2 for classical, fermi and Bosonic for i_particle in range(4): i_flavor = flavor[i_collision,i_particle] if particle_type[i_flavor] == 1: tf[i_particle] = 1 - (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] elif particle_type[i_flavor] == 2: tf[i_particle] = 1 + (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] else: tf[i_particle] = 1 distribution_terms = f[0]*f[1]*tf[2]*tf[3]*amplitude_square/degeneracy[flavor[i_collision,0]]/degeneracy[flavor[i_collision,1]] - tf[0]*tf[1]*f[2]*f[3]*amplitude_square/degeneracy[flavor[i_collision,2]]/degeneracy[flavor[i_collision,3]] ​ **2-3 Collision: ** f = cuda.local.array(shape=5, dtype=float64) f[0] = f_x_p_t0level[flavor[i_collision,0], i_phase_grid0] f[1] = f_x_p_t0level[flavor[i_collision,1], i_phase_grid1] f[2] = f_x_p_t0level[flavor[i_collision,2], i_phase_grid2] f[3] = f_x_p_t0level[flavor[i_collision,3], i_phase_grid3] f[4] = f_x_p_tilevel[p_type, i_grid] # feed values of distribution function and its quantum correction tf = cuda.local.array(shape=5, dtype=float64) # particle_type: 0, 1, 2 for classical, fermi and Bosonic for i_particle in range(5): i_flavor = flavor[i_collision,i_particle] if particle_type[i_flavor] == 1: tf[i_particle] = 1 - (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] elif particle_type[i_flavor] == 2: tf[i_particle] = 1 + (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] else: tf[i_particle] = 1 distribution_terms = (1/(2*math.pi*hbar)**3)*f[0]*f[1]*tf[2]*tf[3]*tf[4]*amplitude_square/degeneracy[flavor[i_collision,0]]/degeneracy[flavor[i_collision,1]] - tf[0]*tf[1]*f[2]*f[3]*f[4]*amplitude_square/degeneracy[flavor[i_collision,2]]/degeneracy[flavor[i_collision,3]]/degeneracy[flavor[i_collision,4]] ​ **3-2 Collision: ** f = cuda.local.array(shape=5, dtype=float64) f[0] = f_x_p_t0level[flavor[i_collision,0], i_phase_grid0] f[1] = f_x_p_t0level[flavor[i_collision,1], i_phase_grid1] f[2] = f_x_p_t0level[flavor[i_collision,2], i_phase_grid2] f[3] = f_x_p_t0level[flavor[i_collision,3], i_phase_grid3] f[4] = f_x_p_tilevel[p_type, i_grid] # feed values of distribution function and its quantum correction tf = cuda.local.array(shape=5, dtype=float64) # particle_type: 0, 1, 2 for classical, fermi and Bosonic for i_particle in range(5): i_flavor = flavor[i_collision,i_particle] if particle_type[i_flavor] == 1: tf[i_particle] = 1 - (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] elif particle_type[i_flavor] == 2: tf[i_particle] = 1 + (2*math.pi*hbar)**3*f[i_particle]/degeneracy[i_flavor] else: tf[i_particle] = 1 distribution_terms = f[0]*f[1]*f[2]*tf[3]*tf[4]*amplitude_square/degeneracy[flavor[i_collision,0]]/degeneracy[flavor[i_collision,1]]/degeneracy[flavor[i_collision,2]] - (1/(2*math.pi*hbar)**3)*tf[0]*tf[1]*tf[2]*f[3]*f[4]*amplitude_square/degeneracy[flavor[i_collision,3]]/degeneracy[flavor[i_collision,4]] Calculate amplitude_square； For a specific and detailed description, please refer to amplitude_square, where the function is thoroughly explained. Calculate collision term ​ **2-2 Collision: ** The “symmetric sampling” method is used to ensure the conservation of particle number, the details of which can be found in the paper published by Prof. Jun-Jie Zhang. Towards a full solution of the relativistic Boltzmann equation for quark-gluon matter on GPUs if flavor0==flavor1: symmetry_factor = 0.5 else: symmetry_factor = 1.0 # accumulate collision kernel # some factors are compensated later result = distribution_terms*symmetry_factor\\ *hbar**2*c/Ja*int_volume/(momentum_product*64*math.pi**2) cuda.atomic.add(collision_term0level, \\ (flavor0, i_phase_grid0), -result/dp[flavor0]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor1, i_phase_grid1), -result/dp[flavor1]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor2, i_phase_grid2), result/dp[flavor2]*dp[p_type]) cuda.atomic.add(collision_termilevel, (p_type, i_grid), result) ​ **2-3 Collision: ** if flavor[i_collision,0]==flavor[i_collision,1]: symmetry_factor = 0.5 else: symmetry_factor = 1.0 # accumulate collision kernel # some factors are compensated later result = distribution_terms*symmetry_factor*\\ hbar**3*c*int_volume/(momentum_product*128*math.pi**2)/Ja cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,0], i_phase_grid0), -result/dp[flavor[i_collision,0]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,1], i_phase_grid1), -result/dp[flavor[i_collision,1]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,2], i_phase_grid2), result/dp[flavor[i_collision,2]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,3], i_phase_grid3), result/dp[flavor[i_collision,3]]*dp[p_type]) cuda.atomic.add(collision_termilevel, (p_type, i_grid), result) ​ **3-2 Collision: ** if flavor[i_collision,0]==flavor[i_collision,1]==flavor[i_collision,2]: symmetry_factor = 1/3 elif flavor[i_collision,0]==flavor[i_collision,1] or \\ flavor[i_collision,1]==flavor[i_collision,2] or \\ flavor[i_collision,0]==flavor[i_collision,2]: symmetry_factor = 0.5 else: symmetry_factor = 1.0 # accumulate collision kernel # some factors are compensated later result = distribution_terms*symmetry_factor*\\ hbar**3*c*int_volume/(momentum_product*128*math.pi**2)/Ja cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,0], i_phase_grid0), -result/dp[flavor[i_collision,0]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,1], i_phase_grid1), -result/dp[flavor[i_collision,1]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,2], i_phase_grid2), -result/dp[flavor[i_collision,2]]*dp[p_type]) cuda.atomic.add(collision_term0level, \\ (flavor[i_collision,3], i_phase_grid3), result/dp[flavor[i_collision,3]]*dp[p_type]) cuda.atomic.add(collision_termilevel, (p_type, i_grid), result)"
  },"/jekyll/2022-07-04-Collision_database.html": {
    "title": "Collision_database",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-04-Collision_database.html",
    "body": "The program primarily addresses collision types and scattering matrix element calculations in the QGP system and Fusion system. To understand the background and principles of the application of the program you can refer to the following article Towards a full solution of the relativistic Boltzmann equation for quark-gluon matter on GPUs QGP system Quark-Gluon Plasma is a phase state under quantum chromodynamics in an environment of very high temperature and density, with quarks and gluons present in the system. Three collision scenarios are considered in the RGB-Maxwell program, 2-2 collisions, 2-3 collisions, and 3-2 collisions. collision_type_for_all_species（） Main parameters in the program particle_order indexes the particles used in the collision calculation in order. ‘u (0), d (1), s (2), ubar (3), dbar (4), sbar (5), fluon (6)’ particle_order = 'u (0), d (1), s (2), ubar (3), dbar (4), sbar (5), fluon (6)' Main parameters in the program flavor22 Three layers of data, with the first layer representing the seven particles, the second layer representing all collision types possible for that particle, and the third layer representing the 2-2 collision participating particle types flavor22=np.array([[[0,0,0,0],[1,0,1,0],[2,0,2,0],[4,0,4,0],[5,0,5,0],[6,0,6,0], \\ [3,0,3,0],[4,1,3,0],[5,2,3,0],[6,6,3,0]], \\ [[0,1,0,1],[1,1,1,1],[2,1,2,1],[3,1,3,1],[5,1,5,1],[6,1,6,1], \\ [4,1,4,1],[3,0,4,1],[5,2,4,1],[6,6,4,1]], \\ [[0,2,0,2],[1,2,1,2],[2,2,2,2],[3,2,3,2],[4,2,4,2],[6,2,6,2], \\ [5,2,5,2],[3,0,5,2],[4,1,5,2],[6,6,5,2]], \\ [[1,3,1,3],[2,3,2,3],[3,3,3,3],[4,3,4,3],[5,3,5,3],[6,3,6,3], \\ [0,3,0,3],[1,4,0,3],[2,5,0,3],[6,6,0,3]], \\ [[0,4,0,4],[2,4,2,4],[3,4,3,4],[4,4,4,4],[5,4,5,4],[6,4,6,4], \\ [1,4,1,4],[0,3,1,4],[2,5,1,4],[6,6,1,4]], \\ [[0,5,0,5],[1,5,1,5],[3,5,3,5],[4,5,4,5],[5,5,5,5],[6,5,6,5], \\ [2,5,2,5],[0,3,2,5],[1,4,2,5],[6,6,2,5]], \\ [[0,6,0,6],[1,6,1,6],[2,6,2,6],[3,6,3,6],[4,6,4,6],[5,6,5,6], \\ [6,6,6,6],[0,3,6,6],[1,4,6,6],[2,5,6,6]]],dtype=np.int32) Main parameters in the program collision_type22 Two layers of data, the first representing the seven particles and the second representing all the collision types that the particle may undergo collision_type22=np.array([[1,0,0,0,0,5,2,3,3,4], \\ [0,1,0,0,0,5,2,3,3,4], \\ [0,0,1,0,0,5,2,3,3,4], \\ [0,0,1,0,0,5,2,3,3,4], \\ [0,0,0,1,0,5,2,3,3,4], \\ [0,0,0,0,1,5,2,3,3,4], \\ [5,5,5,5,5,5,6,4,4,4]],dtype=np.int32) The collision types are shown below： Amplitude_square() ——Scattering Matrix Element Calculation The program focuses on the calculation of scattering matrix elements during 2-2 collisions. def Amplitude_square(m1_squared,m2_squared,m3_squared,mp_squared,\\ k10,k20,k30,p0,collision_type_indicator,\\ k1x,k1y,k1z,k2x,k2y,k2z,k3x,k3y,k3z,px,py,pz,hbar,c,lambdax): # change the values here alpha_s = 0.3 dF = 3. CA = 3. CF = 4/3 dA = 8. g = math.sqrt(4*math.pi*alpha_s) mg_regulator_squared = 0.5**2 E1 = k10 E2 = k20 E3 = k30 Ep = p0 s = (E1+E2)**2-(k1x+k2x)**2-(k1y+k2y)**2-(k1z+k2z)**2 t = (E1-E3)**2-(k1x-k3x)**2-(k1y-k3y)**2-(k1z-k3z)**2 u = (E1-Ep)**2-(k1x-px)**2-(k1y-py)**2-(k1z-pz)**2 # spin and color averaged # amplitude squared if collision_type_indicator==0: # q1+q2-&gt;q1+q2 return a_q1q2_q1q2(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==1: # q+q-&gt;q+q return a_qq_qq(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==2: # q+q_bar -&gt; q+q_bar return a_qqbar_qqbar(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==3: # q1+q1_bar -&gt; q2+q2_bar return a_q1q1bar_q2q2bar(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==4: # q1+q1_bar -&gt; gg return a_q1q1bar_gg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==5: # q+g -&gt; q+g return a_qg_qg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) elif collision_type_indicator==6: # gg -&gt; gg return a_gg_gg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared) @cuda.jit(device=True) def a_q1q2_q1q2(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 8*(g**4)*(dF**2)*(CF**2)/dA*((s*s+u*u)/(t-mg_regulator_squared)**2) @cuda.jit(device=True) def a_qq_qq(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 8*(g**4)*(dF**2)*(CF**2)/dA*((s*s+u*u)/((t-mg_regulator_squared)**2)+\\ (s*s+t*t)/((u-mg_regulator_squared)**2))+\\ 16*(g**4)*dF*CF*(CF-CA/2)*(s*s)/((t-mg_regulator_squared)*(u-mg_regulator_squared)) @cuda.jit(device=True) def a_qqbar_qqbar(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 8*(g**4)*(dF**2)*(CF**2)/dA*((s*s+u*u)/((t-mg_regulator_squared)**2)+\\ (u*u+t*t)/(s*s))+\\ 16*(g**4)*dF*CF*(CF-CA/2)*(u*u)/((t-mg_regulator_squared)*s) @cuda.jit(device=True) def a_q1q1bar_q2q2bar(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 8*(g**4)*(dF**2)*(CF**2)/dA*((t*t+u*u)/(s*s)) @cuda.jit(device=True) def a_q1q1bar_gg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 8*g**4*dF*CF**2*(u/(t-mg_regulator_squared)+t/(u-mg_regulator_squared))-\\ 8*g**4*dF*CF*CA*(t**2+u**2)/(s**2) @cuda.jit(device=True) def a_qg_qg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return -8*g**4*dF*CF**2*(u/s+s/(u-mg_regulator_squared))+\\ 8*g**4*dF*CF*CA*(s*s+u*u)/((t-mg_regulator_squared)**2) @cuda.jit(device=True) def a_gg_gg(g,s,t,u,dF,CA,CF,dA,mg_regulator_squared): return 16*g**4*dA*CA**2*(3-s*u/((t-mg_regulator_squared)**2) -s*t/((u-mg_regulator_squared)**2) -t*u/(s**2)) Fusion system The Fusion system mainly contains H,H2,H2+,H+,e-, 5 kinds of particles. Three collision scenarios are considered in the RGB-Maxwell framework, 2-2 collision, 2-3 collision, and 3-2 collision. collision_type_for_all_species() Main parameters in the program particle_order indexes the particles used in the collision calculation in order. ‘u (0), d (1), s (2), ubar (3), dbar (4), sbar (5), fluon (6)’ particle_order = 'H+ (0), H2 (1), H (2), H2+ (3), e- (4)' flavor[‘2TO2’]，flavor[‘2TO3’]，flavor[‘3TO2’]—-represent 2-2 collisions, 2-3 collisions, and 3-2 collisions respectively. Three layers of data, with the first layer representing the seven particles, the second layer representing all collision types possible for that particle, and the third layer representing the 2-2 collision participating particle types, where 10001 represents null. flavor['2TO2']=np.array([[[1,0,1,0], [10001,10001,10001,10001]], [[0,1,0,1], [4,1,4,1]], [[0,1,3,2], [10001,10001,10001,10001]], [[0,1,2,3], [10001,10001,10001,10001]], [[1,4,1,4], [10001,10001,10001,10001]]],dtype=np.int64) flavor['2TO3']=np.array([[[0,1,3,4,0], [1,2,1,4,0], [10001,10001,10001,10001,10001], [10001,10001,10001,10001,10001]], [[1,2,0,4,1], [10001,10001,10001,10001,10001], [10001,10001,10001,10001,10001], [10001,10001,10001,10001,10001]], [[2,1,3,4,2], [10001,10001,10001,10001,10001], [10001,10001,10001,10001,10001], [10001,10001,10001,10001,10001]], [[0,1,0,4,3], [1,2,2,4,3], [1,4,4,4,3], [10001,10001,10001,10001,10001]], [[0,1,0,3,4], [1,2,0,1,4], [2,1,2,3,4], [1,4,3,4,4]]],dtype=np.int64) collision_type[‘2TO2’], collision_type[‘2TO3’], collision_type[‘3TO2’]—-represent 2-2 collisions, 2-3 collisions, and 3-2 collisions respectively. Two layers of data, the first representing the seven particles and the second representing all the collision types that the particle may undergo, where 10001 represents null. collision_type['2TO2']=np.array([[1,10001],[1,2],[0,10001],[0,10001],[2,10001]],dtype=np.int64) collision_type['2TO3']=np.array([[0,1,10001,10001],\\ [1,10001,10001,10001],\\ [2,10001,10001,10001],\\ [0,2,3,10001],\\ [0,1,2,3]],dtype=np.int64) The collision types are shown below: Amplitude_square() ——Scattering Matrix Element Calculation The program focuses on the calculation of scattering matrix elements during 2-2, 2-3, and 3-2 collisions. 2-2 Collisions @cuda.jit(device=True) def Amplitude_square(m1_squared,m2_squared,m3_squared,mp_squared,\\ k10,k20,k30,p0,collision_type_indicator,\\ k1x,k1y,k1z,k2x,k2y,k2z,k3x,k3y,k3z,px,py,pz,hbar,c,lambdax): s = m1_squared*c**2 + m2_squared*c**2 + 2*(k10*k20-k1x*k2x-k1y*k2y-k1z*k2z) I = math.sqrt((k10*k20-k1x*k2x-k1y*k2y-k1z*k2z)**2-m1_squared*m2_squared*c**4) # Only modify here if collision_type_indicator==0: return 10000. elif collision_type_indicator==1: return 10000. elif collision_type_indicator==2: return 10000. else: return 0. 2-3 Collisions @cuda.jit(device=True) def Amplitude_square(m1_squared,m2_squared,m3_squared,m4_squared,mp_squared,\\ k10,k20,k30,k40,p0,collision_type_indicator,\\ k1x,k1y,k1z,k2x,k2y,k2z,k3x,k3y,k3z,k4x,k4y,k4z,\\ px,py,pz,hbar,c,lambdax): s = m1_squared*c**2 + m2_squared*c**2 + 2*(k10*k20-k1x*k2x-k1y*k2y-k1z*k2z) I = math.sqrt((k10*k20-k1x*k2x-k1y*k2y-k1z*k2z)**2-m1_squared*m2_squared*c**4) # Only modify here if collision_type_indicator==0: return 10000. elif collision_type_indicator==1: return 10000. elif collision_type_indicator==2: return 10000. elif collision_type_indicator==3: return 10000. else: return 0. 3-2 Collisions @cuda.jit(device=True) def Amplitude_square(m1_squared,m2_squared,m3_squared,m4_squared,mp_squared,\\ k10,k20,k30,k40,p0,collision_type_indicator,\\ k1x,k1y,k1z,k2x,k2y,k2z,k3x,k3y,k3z,k4x,k4y,k4z,\\ px,py,pz,hbar,c,lambdax): s = m1_squared*c**2 + m2_squared*c**2 + 2*(k10*k20-k1x*k2x-k1y*k2y-k1z*k2z) I = math.sqrt((k10*k20-k1x*k2x-k1y*k2y-k1z*k2z)**2-m1_squared*m2_squared*c**4) # Only modify here if collision_type_indicator==0: return 10000. elif collision_type_indicator==1: return 10000. elif collision_type_indicator==2: return 10000. elif collision_type_indicator==3: return 10000. else: return 0."
  },"/jekyll/2022-07-03-Plasma.html": {
    "title": "Plasma",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-03-Plasma.html",
    "body": "This program mainly deals with the temporal evolution of multi-particle systems, including： Parallel computation of single-particle distribution function； Collision term Calculation； Drifit term Calculation； Charge density and current density calculation； Based on Jefimenko’s equations, the electric and magnetic fields can be solved； External Electromagnetic Force Calculation. To understand the application background and principles of the program, you can refer to the following article. Towards a full solution of the relativistic Boltzmann equation for quark-gluon matter on GPUs The advantages of the program Parallelize the program using CUDA； Realized the conversion between flexible unit system and international unit system； Use Ray framework to efficiently call multiple servers.； Create a clear framework to integrate and call each sub-module in an orderly manner； Ensure momentum conservation in the simulation process by using the “symmetric sampling” method； Reduce the diffusion phenomenon in the simulation process by using the Unconditionally Positivity Preserving Finite Difference Scheme (UPFD) and Flux Limiter method； Utilize GPU for efficient integration. The structure of the program Init collision_type_for_all_species（） Plasma（） plasma_single_GPU（） check_input_legacy（） EMsolver（） Main proceed_one_step（） PF_PT（） external_forces（） Vlasov（） Collision（） Drift（） update_f_single_GPU（） return_self（） other_calculation find_largest_time_steps（） boundary_coding（） The operational logic of the entire program is depicted in the ensuing diagram: collision_type_for_all_species（） The main purpose of this function is to establish and configure collision parameters.： 1、Provides an index of the particle types used in the program； particle_order = 'u (0), d (1), s (2), ubar (3), dbar (4), sbar (5), fluon (6)' 2、Provides an index of the type of reaction performed by the particle； collision_type22=np.array([[1,0,0,0,0,5,2,3,3,4], ...) 3、Provides an index of the particles used in the reaction type. flavor22=np.array([[[0,0,0,0],[1,0,1,0],[2,0,2,0],[4,0,4,0],[5,0,5,0],[6,0,6,0], \\ [3,0,3,0],[4,1,3,0],[5,2,3,0],[6,6,3,0]], ...) check_input_legacy(f, dt, \\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ npx, npy, npz, half_px, half_py, half_pz,\\ masses, charges,\\ sub_region_relations,\\ num_gpus_for_each_region,\\ num_samples,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type) For a specific and detailed description, please refer to collision_type_for_all_species(), where the function is thoroughly explained. Plasma（） This function primarily constructs the class, initializes the pertinent parameters employed by the program, and subsequently transfers said parameters to the Graphics Processing Unit (GPU). The determination of the input parameter type is conducted prior to the initialization process.： check_input_legacy(f, dt, \\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ npx, npy, npz, half_px, half_py, half_pz,\\ masses, charges,\\ sub_region_relations,\\ num_gpus_for_each_region,\\ num_samples,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type) For a specific and detailed description, please refer to Input parameters, where the function is thoroughly explained. The maximal temporal increment necessary for the electromagnetic wave propagation from position A to position B prior to the initialization of EMsolver() is determined: def find_largest_time_steps(dx_o, dy_o, dz_o, x_left_boundary_o, y_left_boundary_o, z_left_boundary_o, \\ dx_s, dy_s, dz_s, x_left_boundary_s, y_left_boundary_s, z_left_boundary_s, \\ x_grid_size_o, y_grid_size_o, z_grid_size_o, \\ x_grid_size_s, y_grid_size_s, z_grid_size_s,\\ dt, c): plasma_single_GPU（） The primary function of the program involves receiving the parameters communicated by the Central Processing Unit (CPU) and transmitting them to the Graphics Processing Unit (GPU). Moreover, the boundary conditions are handled in accordance with distinct blocks. Where bound_indicator is: indicator, indexes represent different surfaces of the block： 0→ back; 1→ front; 2→ left; 3→ right side; 4→ below; 5→ Above； sub_region_relations = {'indicator': [[0,3,4],[0,2,4],[0,3,5],[0,2,5],\\ [1,3,4],[1,2,4],[1,3,5],[1,2,5]]} To facilitate the interaction of block boundaries, the ghost boundaries method is employed. This method entails the following steps: Initially, the bound_indicator is utilized to identify potential overlaps between the current block and other blocks; Subsequently, the boundary conditions along the negative axis of the coordinate system are adjusted; Finally, the size of the calculation area is modified by subtracting the portion that represents the “coincidence surface. for i_reg in range(number_regions): # index for rho/J in generating EM self.id_xl, self.id_xr, self.id_yl, self.id_yr, self.id_zl, self.id_zr = 0, self.nx, 0, self.ny, 0, self.nz # the source region needs to be shrinked, according to the ghost boundaries self.x_left_bound_adj, self.y_left_bound_adj, self.z_left_bound_adj = self.x_left_bound, self.y_left_bound, self.z_left_bound self.nx_adj, self.ny_adj, self.nz_adj = self.nx, self.ny, self.nz # check the -x, -y, -z, +x, +y, +z directions if 0 in bound_indicator: self.nx_adj -= 1 self.x_left_bound_adj += self.dx self.id_xl += 1 if 1 in bound_indicator: self.nx_adj -= 1 self.id_xr -= 1 if 2 in bound_indicator: self.ny_adj -= 1 self.y_left_bound_adj += self.dy self.id_yl += 1 if 3 in bound_indicator: self.ny_adj -= 1 self.id_yr -= 1 if 4 in bound_indicator: self.nz_adj -= 1 self.z_left_bound_adj += self.dz self.id_zl += 1 if 5 in bound_indicator: self.nz_adj -= 1 self.id_zr -= 1 The initialization process precedes the electromagnetic (EM) calculation and involves the transmission of parameters: self.EMsolver.append(EMsolver(self.len_time_snapshots[i_reg], \\ self.nx_o[i_reg], self.ny_o[i_reg], self.nz_o[i_reg], \\ self.nx_adj, self.ny_adj, self.nz_adj,\\ self.dx_o[i_reg], self.dy_o[i_reg], self.dz_o[i_reg], \\ self.x_left_bound_o[i_reg], self.y_left_bound_o[i_reg], \\ self.z_left_bound_o[i_reg], \\ self.dx, self.dy, self.dz, \\ self.x_left_bound_adj, self.y_left_bound_adj, self.z_left_bound_adj, \\ self.dt, self.epsilon0, self.c)) EMsolver() The primary function of the program involves the initialization of electromagnetic (EM) calculation parameters. Additionally, it performs simultaneous computations of Coff_E and Coff_B。 For a specific and detailed description, please refer to EMsolver, where the function is thoroughly explained. Calculation Coff_EandCoff_B。 self.coeff_E = 1/(4*math.pi*epsilon0)*dx_s*dy_s*dz_s self.coeff_B = -1/(4*math.pi*epsilon0*c**2)*dx_s*dy_s*dz_s boundary_coding() surface_index_taken in the code indicates a boundary that will be used elsewhere（The inner part of the picture, where the arrow starts）； The surface index in the code represents the boundary that will be replaced（In the outer part of the image, the arrow points to the position）； def boundary_coding(nx, ny, nz, npx, npy, npz, \\ number_momentum_levels, num_particle_species, \\ bound_indicator): # these are the boundaries that need to be taken surface_index_taken = np.array([[1, 2, 0, ny, 0, nz],\\ [nx-2, nx-1, 0, ny, 0, nz],\\ [0, nx, 1, 2, 0, nz],\\ [0, nx, ny-2, ny-1, 0, nz],\\ [0, nx, 0, ny, 1, 2],\\ [0, nx, 0, ny, nz-2, nz-1]]) # these are the boundaries that need to be exchanged surface_index = np.array([[0, 1, 0, ny, 0, nz],\\ [nx-1, nx, 0, ny, 0, nz],\\ [0, nx, 0, 1, 0, nz],\\ [0, nx, ny-1, ny, 0, nz],\\ [0, nx, 0, ny, 0, 1],\\ [0, nx, 0, ny, nz-1, nz]]) return surface_index_taken, surface_index Main()——The main part of the program proceed_one_step（）——Plasma The primary functions are delineated as follows: Evaluation of all blocks and determination of the corresponding time increment (dt) deemed suitable； Time evolution in accordance with the aforementioned dt: Computation of charge density and current density via the distribution function.； Calculation of electromagnetic fields employing the Jefimenko’s equation.； Estimation of remote electromagnetic forces； Computation of Drifit terms； Computation of Collision terms； Updating the distribution function——f(t+1) = dt*(f(t) - Vt - Dt + Ct) Exchange coordinate boundaries, electromagnetic fields. def proceed_one_step(self, i_time, total_time_steps, processes = {'VT':1., 'DT':1., 'CT':1.}, \\ BEx = 0., BEy = 0., BEz = 0., BBx = 0., BBy = 0., BBz = 0.): whether_terminate = [] # evaluate the distribution function in all regions for i_reg in range(self.number_regions): whether_terminate.append(self.plasmas[i_reg].proceed_one_step.remote(i_time, total_time_steps, self.global_dt, try_evaluate = True, processes = processes, BEx = BEx[i_reg], BEy = BEy[i_reg], BEz = BEz[i_reg], BBx = BBx[i_reg], BBy = BBy[i_reg], BBz = BBz[i_reg])) for i_reg in range(self.number_regions): whether_terminate[i_reg] = ray.get(whether_terminate[i_reg]) # terminate if illlegal results have been obtained if any(whether_terminate) == True: raise AssertionError(\"The code has been terminated since the obtained distribution is unphysical!\") # exchange the boundaries after evaluation if self.number_regions &gt; 1: self.exchange_boundaries() # exchange EM fields for Vlasov term if processes['VT']&gt;0.5: self.exchange_EM_fields() # load stream_ticker # stream_ticker transfers a small data from GPU to CPU # this gives a signal to the GPU that whether each time step is finished self.acquire_values(\"stream_ticker\") proceed_one_step（）——Plasma_Single_GPU This function mainly passes the electromagnetic fields to the GPU and also makes distribution function update program calls； def proceed_one_step(self, current_time_step, total_time_steps, \\ dt, try_evaluate, \\ processes = {'VT':1., 'DT':1., 'CT':1.},\\ BEx = 0., BEy = 0., BEz = 0., BBx = 0., BBy = 0., BBz = 0.): # sending the background EM fields to GPU BEx, BEy, BEz, BBx, BBy, BBz = cupy.asarray(BEx), cupy.asarray(BEy), cupy.asarray(BEz),\\ cupy.asarray(BBx), cupy.asarray(BBy), cupy.asarray(BBz) # evalute new distribution whether_terminate = self.PF_PT(processes, BEx, BEy, BEz, BBx, BBy, BBz, \\ dt, current_time_step, total_time_steps) return whether_terminate PF_PT（） The fundamental principle governing this function primarily relies on input parameters to discern the requisite terms, which predominantly encompass the drift term, Vlasov term, external force, and collision term. DT----Drift() VT----Vlasov() VT and eval_External_Forces----external_forces() CT----Collision() Through parameter selection, the program can solve for partial results, thus helping the user to refine the scope and focus of the study. def PF_PT(self, processes, BEx, BEy, BEz, BBx, BBy, BBz, dt, current_time_step, total_time_steps): # calculate the external forces if processes['VT']&gt;0.5: BEx, BEy, BEz, BBx, BBy, BBz = cupy.asarray(BEx), cupy.asarray(BEy), cupy.asarray(BEz),\\ cupy.asarray(BBx), cupy.asarray(BBy), cupy.asarray(BBz) self.external_forces(BEx, BEy, BEz, BBx, BBy, BBz) self.rho_J_to_EB() else: self.Fx, self.Fy, self.Fz = cupy.zeros_like(self.f), cupy.zeros_like(self.f), cupy.zeros_like(self.f) # if 'CT' is instantiated, calculate the collision terms at all levels if processes['CT'] &gt; 0.5: # calculate collision term self.CT = Collision_term(self.flavor, self.collision_type, \\ self.particle_type, self.degeneracy, self.num_samples,\\ self.f, self.masses, self.total_phase_grids, self.rng_states,\\ self.num_particle_species, \\ self.npx, self.npy, self.npz, self.nx, self.ny, self.nz, self.dp, \\ self.half_px, self.half_py, self.half_pz, \\ self.dpx, self.dpy, self.dpz, \\ self.blockspergrid_total_phase, self.threadsperblock, \\ self.middle_npx, self.middle_npy, self.middle_npz, \\ self.number_momentum_levels,\\ self.hbar,self.c,self.lambdax,self.allowed_collision_type) else: # otherwise set collision to be zero self.CT = cupy.zeros_like(self.f) # evaluate Drift and Vlasov terms whether_terminate = self.DT_VT(self.f, dt, current_time_step, processes) return whether_terminate rho_J_to_EB（） Initially, the charge density and current density are computed for the given context： self.electric_rho, self.electric_Jx, self.electric_Jy, self.electric_Jz = \\ charged_density(self.f, self.num_particle_species, self.total_spatial_grids, \\ self.masses, self.charges, \\ self.total_phase_grids, self.momentum_volume_element, self.npx, self.npy, self.npz, \\ self.nx, self.ny, self.nz, self.half_px, self.half_py, self.half_pz, \\ self.dx, self.dy, self.dz, self.dpx, self.dpy, self.dpz, self.number_momentum_levels,\\ self.blockspergrid_total_phase, self.threadsperblock, self.c) For a specific and detailed description, please refer to Macro_quantities, where the function is thoroughly explained. Then, based on the charge density and current density, the electric and magnetic fields are solved using the Jefimenko’s equations. if self.rho_J_method == \"raw\": for i_reg in range(self.number_regions): self.EMsolver[i_reg].Jefimenko_solver(self.electric_rho.reshape([self.nx, self.ny, self.nz])[self.id_xl:self.id_xr, \\ self.id_yl:self.id_yr,self.id_zl:self.id_zr].flatten(),self.electric_Jx.reshape([self.nx, self.ny, self.nz])[self.id_xl:self.id_xr, \\ self.id_yl:self.id_yr,self.id_zl:self.id_zr].flatten(),self.electric_Jy.reshape([self.nx, self.ny, self.nz])[self.id_xl:self.id_xr, \\ self.id_yl:self.id_yr,self.id_zl:self.id_zr].flatten(),self.electric_Jz.reshape([self.nx, self.ny, self.nz])[self.id_xl:self.id_xr, self.id_yl:self.id_yr,self.id_zl:self.id_zr].flatten(), self.quasi_neutral) self.Ex_dis[i_reg], self.Ey_dis[i_reg], self.Ez_dis[i_reg], \\ self.Bx_dis[i_reg], self.By_dis[i_reg], self.Bz_dis[i_reg] = \\ self.EMsolver[i_reg].GEx.get(), self.EMsolver[i_reg].GEy.get(), self.EMsolver[i_reg].GEz.get(),\\ self.EMsolver[i_reg].GBx.get(), self.EMsolver[i_reg].GBy.get(), self.EMsolver[i_reg].GBz.get() elif self.rho_J_method == 'quasi_neutral': pass else: raise AssertionError(\"Plasma method must be raw or quasi_neutral!\") For a specific and detailed description, please refer to EMsolver, where the function is thoroughly explained. external_forces（） remote electromagnetic force calculation. def external_forces(self, BEx, BEy, BEz, BBx, BBy, BBz): self.Ex_total, self.Ey_total, self.Ez_total, self.Bx_total, self.By_total, self.Bz_total = self.Ex.sum(axis=0)+BEx, self.Ey.sum(axis=0)+BEy, self.Ez.sum(axis=0)+BEz, \\ self.Bx.sum(axis=0)+BBx, self.By.sum(axis=0)+BBy, self.Bz.sum(axis=0)+BBz self.Fx, self.Fy, self.Fz = \\ External_forces(self.masses, self.charges,\\ self.total_phase_grids, self.num_particle_species, \\ self.npx,self.npy,self.npz,self.nx,self.ny,self.nz, \\ self.half_px, self.half_py, self.half_pz, \\ self.dx, self.dy, self.dz, self.dpx, self.dpy, self.dpz, \\ self.blockspergrid_total_phase, self.threadsperblock, self.number_momentum_levels,\\ self.Ex_total, self.Ey_total, self.Ez_total, self.Bx_total, self.By_total, self.Bz_total, self.c) print(self.By_total.sum(), self.Bz_total.sum(),cupy.abs(self.Fx).sum(),cupy.abs(self.Fy).sum(),cupy.abs(self.Fz).sum()) For a specific and detailed description, please refer to Externel-forces, where the function is thoroughly explained. Collision() Collision term calculation: self.CT = Collision_term(self.flavor, self.collision_type, \\ self.particle_type, self.degeneracy, self.num_samples,\\ self.f, self.masses, self.total_phase_grids, self.rng_states,\\ self.num_particle_species, \\ self.npx, self.npy, self.npz, self.nx, self.ny, self.nz, self.dp, \\ self.half_px, self.half_py, self.half_pz, \\ self.dpx, self.dpy, self.dpz, \\ self.blockspergrid_total_phase, self.threadsperblock, \\ self.middle_npx, self.middle_npy, self.middle_npz, \\ self.number_momentum_levels,\\ self.hbar,self.c,self.lambdax,self.allowed_collision_type) For a specific and detailed description, please refer to Collision_term(), where the function is thoroughly explained. Vlasov_Drift() Calculation of the Vlasov and Drift terms： def DT_VT(self, f_local, dt, current_time_step, processes): self.f = Drift_Vlasov_terms(f_local, self.Fx, self.Fy, self.Fz, \\ self.masses, self.total_phase_grids, self.num_particle_species, \\ self.npx, self.npy, self.npz, self.nx, self.ny, self.nz,\\ self.half_px, self.half_py, self.half_pz, \\ self.dx, self.dy, self.dz, self.dpx, self.dpy, self.dpz, self.number_momentum_levels,\\ self.x_bound_config, self.y_bound_config, self.z_bound_config, \\ self.blockspergrid_total_phase, self.threadsperblock,\\ self.CT, dt, self.c, current_time_step, \\ processes['DT'], processes['VT'], self.drift_order) if current_time_step%time_stride_back==0 and current_time_step != 0 : # check is the obtained self.fp is legal. whether_legal, illegal_type, value, which_species, which_position = check_legacy_of_distributions(self.f, self.particle_type, self.hbar, self.dt, self.degeneracy) if whether_legal == 1: self.last_f = self.f else: self.f = self.last_f return 0 return 1 For a specific and detailed description, please refer to Vlasov_Drifit_terms, where the function is thoroughly explained. acquire_values() The function extracts the result of the calculation by setting the parameters def acquire_values(self, quantity): quantities_required = {} for i_reg in range(self.number_regions): quantities_required[i_reg] = ray.get(self.plasmas[i_reg].return_self.remote(quantity)) return quantities_required return_self() The function is primarily responsible for data transmission and acquisition, transferring the calculation results from Plasma_single_GPU to Plasma. def return_self(self, process): if 'Collision term' == process: return self.CT.get() if 'Distribution' == process: return self.f.get() if 'Forces' == process: return self.Fx.get(), self.Fy.get(), self.Fz.get() if \"Electric rho/J\" == process: return self.electric_rho.get(), self.electric_Jx.get(), self.electric_Jy.get(), self.electric_Jz.get() if \"number_rho/J\" == process: self.get_rho_J() return self.number_rho.get(), self.number_Jx.get(), self.number_Jy.get(), self.number_Jz.get() if \"EM fields on current region\" == process: return self.Ex_total.get(), self.Ey_total.get(), self.Ez_total.get(), self.Bx_total.get(), self.By_total.get(), self.Bz_total.get() if \"EM fields to other regions\" == process: return self.Ex_dis, self.Ey_dis, self.Ez_dis, self.Bx_dis, self.By_dis, self.Bz_dis if \"stream_ticker\" == process: return self.stream_ticker.get()"
  },"/2022-07-01-input-parameters.html": {
    "title": "Input parameters",
    "keywords": "",
    "url": "/2022-07-01-input-parameters.html",
    "body": "​ The RBG-Maxwell framework exhibits a significant level of adaptability and offers a vast array of user-defined parameters, rendering it proficient in facilitating a wide range of plasma simulations. ​ This section presents an introduction to the parameters employed in the RGB-Maxwell program. Differential parameters dx, dy, dz: Infinitesimal differences used in the spatial domain. e.g. dx = dy = dz = 10**(-5) dpx, dpy, dpz: Infinitesimal difference in momentum domain e.g. dpx = dpy = dpz = 10**(-25) dx_o, dy_o, dz_o: Infinitesimal difference of the spatial coordinates in the observation region e.g. dx_o, dy_o, dz_o = [dx]*number_regions, [dy]*number_regions, [dz]*number_regions dt : The infinitesimal time for each time step updation. e.g. dt = 10**(-13) n_step: number of total time steps e.g. n_step = 10001 drift_order: order of drift terms in upwind scheme e.g. drift_order = 2 num_samples: number samples gives the number of sample points in MC integration e.g. num_samples = 100 Grid parameters nx, ny, nz: Number of spatial grids. e.g. nx = ny = nz = 101 npx, npy, npz: Number of momentum grids. e.g. npx, npy, npz = 3, 4, 5 nx_o, ny_o, nz_o: Number of spatial grids in the observation region. e.g. nx_o, ny_o, nz_o = [nx], [ny], [nz] Boundary parameters x_left_bound_o, y_left_bound_o, z_left_bound_o: the left boundaries of the spatial sub-region in the observation region. e.g. x_left_bound_o, y_left_bound_o, z_left_bound_o = \\ ((np.array([19, 19, 19, 19, 0, 0, 0, 0])*12/40-6)/0.197).tolist(),\\ ((np.array([0, 19, 0, 19, 0, 19, 0, 19])*12/40-6)/0.197).tolist(),\\ ((np.array([19, 19, 0, 0, 19, 19, 0, 0])*12/40-6)/0.197).tolist() half_px, half_py, half_pz: Three lists of the momentum length in x,y and z directions. e.g. half_px, half_py, half_pz = np.array([-px_left_bound]*7), \\ np.array([-py_left_bound]*7), np.array([-pz_left_bound]*7) x_bound_config, y_bound_config, z_bound_config: configuretions of the boundary conditions. x_bound_config is of shape [ny, nz, 2] y_bound_config is of shape [nx, nz, 2] z_bound_config is of shape [nx, ny, 2] Particle parameters f: Distribution functions in different spatial regions. e.g. f = [momentum_levels, particle_species, nx*ny*nz*npx*npy*npz]. particle_type: List of particle types for each particle species. e.g. particle_type = [1,1,1,1,1,1,2] masses: List of masses for each particle species. e.g. masses = np.array([0.3,0.3,0.5,0.3,0.3,0.5,0.5],dtype=np.float64) charges: List of charges for each particle species. e.g. charges = np.array([unit_charge*2/3,-unit_charge/3,-unit_charge/3,\\ -unit_charge*2/3,unit_charge/3,unit_charge/3, 0.],dtype=np.float64) degeneracy: List of degenaracies for each particle species. e.g. degeneracy = np.array([6.,6.,6.,6.,6.,6.,16.]) Region parameters num_gpus_for_each_region: each spatial should use the full GPU, this number can be fractional if many regions are chosen and only one GPU is available e.g. num_gpus_for_each_region = 1. region_id: the index of the current spatial region, e.g. region_id = 1 number_regions: total number of spatial regions e.g. number_regions = 8 sub_region_relations: Dictionary of the relative locations amongest the sub-regions. key: 'indicator' gives the index of surfaces to be exchanged. key: 'position' gives the relative positions between the regions. e.g. sub_region_relations = \\ {'indicator': [[0,3,4],[0,2,4],[0,3,5],[0,2,5],\\ [1,3,4],[1,2,4],[1,3,5],[1,2,5]],\\ 'position': [[0, 1, 2, 3, 4, 5, 6, 7],\\ -----base [4, 5, 6, 7, None, None, None, None],\\ -----minus x [None, None, None, None, 0, 1, 2, 3],\\ -----plus x [None, 0, None, 2, None, 4, None, 6],\\ -----minus y [1, None, 3, None, 5, None, 7, None],\\ -----plus y [2, 3, None, None, 6, 7, None, None],\\ -----minus z [None, None, 0, 1, None, None, 4, 5]]} -----plus z Collision parameters flavor: all possible collisions for the given final particle flavor = {'2TO2:, '2TO3':, ;3TO2':} e.g. flavor['2TO2']=np.array([[[1,0,1,0], [10001,10001,10001,10001]], [[0,1,0,1], [4,1,4,1]], [[0,1,3,2], [10001,10001,10001,10001]], [[0,1,2,3], [10001,10001,10001,10001]], [[1,4,1,4], [10001,10001,10001,10001]]],dtype=np.int64) collision_type: an index indicate which collision type the process belongs to collision_type = {'2TO2:, '2TO3':, ;3TO2':} e.g. collision_type['2TO3']=np.array([[0,1,10001,10001],\\ [1,10001,10001,10001],\\ [2,10001,10001,10001],\\ [0,2,3,10001],\\ [0,1,2,3]],dtype=np.int64) Other parameters hbar,c,lambdax,epsilon0: numerical value of hbar,c, lambdax and epsilon0 in Flexible Unit (FU) e.g. hbar, c, lambdax, epsilon0 = 1., 1., 1.6*10**28, 1. This function mainly determines the type of input parameters and helps the user to check them. If there is an error in the input parameter type then an error statement will be provided. def check_input_legacy(f, dt, \\ nx_o, ny_o, nz_o, dx, dy, dz, boundary_configuration, \\ x_left_bound_o, y_left_bound_o, z_left_bound_o, \\ npx, npy, npz, half_px, half_py, half_pz,\\ masses, charges,\\ sub_region_relations,\\ num_gpus_for_each_region,\\ num_samples,\\ flavor, collision_type, particle_type,\\ degeneracy, expected_collision_type):"
  }}
